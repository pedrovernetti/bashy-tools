#!/bin/bash

 # ==================================================== #
 # This script looks better in a maximized window, on   #
 # 1360px or wider screens...                           #
 #                                                      #
 # Run it with the '-h' option for better understanding #
 #                                                      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # Originally written by <pedrovernetti@gmail.com>      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # tested in / thought for Ubuntu 16.04                 #
 # runs in Ubuntu 18.04 probably as well as in 16.04    #
 # ==================================================== #


## Prints a help message (use -h option to properly read it)
help_message ()
{
    printf "Usage: ${0##*/} [OPTIONS] -i INPUT_FILE [OPTIONS]\n\n"
    if [[ "$1" == "full" ]]; then
        printf "  Options:\n\n"
        printf "  -h        print this help message and exit\n"
        printf "  -hl       print the list of supported languages\n"
        printf "  -prepare  install dependencies (\033[1mmust be runned once\033[0m)\n"
        printf "  -?        print the low-level command lines which \033[1mwould be\033[0m called\n\n"
        printf "  -A        convert audio to AAC [#TODO]\n"
        printf "  -a \033[2mFILE\033[0m   take audio from 'FILE' and \033[1mnot\033[0m from the main input\n"
        printf "  -c \033[2mIMG\033[0m    embed 'IMG' to the output as its cover/thumbnail\n"
        printf "  -e        replace the video codec name with that of the encoding library\n"
        printf "  -i \033[2mFILE\033[0m   take audio, video and metadata from 'FILE' (\"main input\")\n"
        printf "  -L \033[2mLNG\033[0m    set 'LNG' as the video language\n"
        printf "  -l \033[2mLNG\033[0m    set 'LNG' as the audio language\n"
        printf "  -n        like '-O', but \033[1mnothing\033[0m is done other than renaming\n"
        printf "  -o \033[2mPATH\033[0m   save the generated output to 'PATH'\n"
        printf "  -O        name the output file according to its title\n"
        printf "  -R        remove every taken file (main input, subtitles, images) at the end\n"
        printf "  -r        remove the file set as the main input at the end\n"
        printf "  -S        take subtitles from the main input, if there is any\n"
        printf "  -s \033[2mLNG\033[0m:\033[2mST\033[0m embed subtitles from 'ST' in the output\n"
        printf "  -t \033[2mTITL\033[0m   set 'TITL' as the title (metadata) of the output\n"
        printf "  -T        like '-t', but takes the filename of the main input as the title\n\n"
        printf "  \033[1;30mFILE\033[0m must be a mkvtoolnix-supported audio/video file\n"
        printf "  \033[1;30mIMG\033[0m  must be a JPEG or any imagemagick-supported image file\n"
        printf "  \033[1;30mPATH\033[0m must be a valid file path to write a Matroska file to\n"
        printf "  \033[1;30mLNG\033[0m  must be the english name or the ISO 639-2B code of a language\n"
        printf "  \033[1;30mST\033[0m   must be a SubRip (.srt) or any ffmpeg-supported subtitles file\n"
        printf "  \033[1;30mTITL\033[0m can be any short piece of text\n\n" 
        printf "Non-JPEG cover images are converted to JPEG before being attached,\n"
        printf "as non-SubRip or non-UTF8 subtitles are all converted to UTF8 SubRip\n"
        printf "before being embedded (uncommon text encodings may not be recognized).\n\n"
        printf "If a subtitles file is cleanly named after the ISO 639-2B code of its\n"
        printf "language, there is no need to make its language explicit in the options.\n\n"
        printf "Examples:\n\n\033[3m${0##*/} -c 'poster.jpg' -s english:'movie.srt' -i 'movie.mp4'\033[0m\n"
        printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named 'movie.mkv' with audio and video\n"
        printf "from 'movie.mp4', 'poster.jpg' as its thumbnail and\n"
        printf "embedded english subtitles extracted from 'movie.srt'.\033[0m\n\n"
        printf "\033[3m${0##*/} -t 'Trailer' -s 'gre.srt' -s 'ger.ssa' -i 'trlr.mp4' -O\033[0m\n"
        printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named after its content (something like\n"
        printf "'Trailer 720p AVC AAC.mkv') with audio and video from\n"
        printf "'trlr.mp4', no specific thumbnail, 'Trailer' as its title\n"
        printf "and embedded greek and german subtitles extracted from\n"
        printf "'gre.srt' and 'ger.srt', respectively.\033[0m\n\n"
        printf "\033[3m${0##*/} -l por -s eng:'sdh.srt' -i 'video.avi' -o 'out.mkv'\033[0m\n"
        printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named 'out.mkv' with audio and video\n"
        printf "from 'video.avi', portuguese as its audio language\n"
        printf "embedded english subtitles extracted from 'sdh.srt'.\033[0m\n"
    elif [[ "$1" == "languages" ]]; then
        printf "ISO 639-2B and ISO 639-1 codes, plus english names for every supported\n"
        printf "language are listed below.\n"
        printf "\033[2mAny of these will be understood, but ISO 639-2B (the 3-letters code)\n"
        printf "is prefered, since it better avoids ambiguity.\033[0m\n\n"
        printf " 639-2B\t639-1\tenglish name\n\n"
        printf "$ISO639_REF\n" | sed -r \
            -e 's/^(.*)[[:space:]]+\|[[:space:]]+(...)[[:space:]]+\|(.*)$/ \2\t\3\t\1/;' \
            -e 's/^(.*\t.*\t.{50}).{4,}/\1.../' | sort | GREP_COLOR='01' egrep -i --color=always '^ ....'
    else
        exit 1
        fi
    printf "\n"
    exit 0
}

## Prints an error (then exits) or warning
error ()
{
    if [[ "$1" == [Ww]* ]]; then printf "\033[1;33m${2//%/%%}\033[0m"
    elif [[ "$1" == [Cc]* ]]; then printf "\033[1;31m${2//%/%%}\033[0m"; exit $3
    else printf "${2//%/%%}"; fi
}

## Installs what is previously needed to run this script
install_me ()
{
    printf "\033[1mDepencies will now be installed...\033[0m\n"
    sudo sed -i -r '/(mkvtoolnix|bunkus)/d' /etc/apt/sources.list
    buffer="deb http://mkvtoolnix.download/ubuntu/"$(lsb_release -sc)"/"
    sudo bash -c "printf \"\\n\\n$buffer ./\" >> /etc/apt/sources.list"
    sudo bash -c "printf \"\\n$buffer ./\" >> /etc/apt/sources.list"
    wget -q -O - https://mkvtoolnix.download/gpg-pub-moritzbunkus.txt | \
        sudo apt-key add -
    sudo apt-get update
    sudo apt-get install file grep sed iconv recode
    sudo apt-get install iso-codes mediainfo mkvtoolnix ffmpeg
    sudo apt-get install imagemagick jpegoptim mat
    if [[ "$1" == "full"  ]]; then sudo cp -uv "$0" /usr/bin/2nicemkv; fi
    exit 0
}

discard_tmps ()
{
    rm -f /tmp/nicemkv_*.utf8 &> /dev/null
    rm -f /tmp/nicemkv.cover.jpg &> /dev/null
}

# EXTRACING THE MKVTOOLNIX LIST OF SUPPORTED LANGUAGES
if hash mkvmerge; then 
    declare -r ISO639_REF=$(mkvmerge --list-languages | \
                tr '[:upper:]' '[:lower:]' | \
                sed -r '1d;2d;/.*[^[:lower:] \t|;].*/d;s/[[:space:]]{2,}/ /g;'; \
                printf "greek | gre | el\nhebrew | heb |\n")
    fi

## Prints the proper ISO-639-3 code for a given language
lang_code ()
{
    local buffer=$(printf "$1" | tr '[:upper:]' '[:lower:]' | \
                sed -r 's/^([[:lower:]]{3})$/| \1 |/')
    local buffer=$(printf "$ISO639_REF" | grep "${buffer,,}" | \
            head -n1 | sed -r 's/^.*\| ?(...) ?\|.*$/\1/')
    if [[ "$buffer" == "" ]]; then printf "UND"
    else printf "$buffer"; fi
}

## Converts the given file to UTF-8 encoding
to_utf8 ()
{
    if ! hash iconv &> /dev/null; then error critical "iconv is missing...\n" 106; fi
    if ! hash recode &> /dev/null; then error critical "recode is missing...\n" 107; fi
    SUB_CS_=$(file -b "$1" | tr '[:lower:]' '[:upper:]')
    if [[ $(printf "$SUB_CS_" | grep -Ec 'UTF.?8') -gt 0 ]]; then SUB_CS_="UTF-8"; return; fi

    west_rx='^(eng|(fr|sw|ic|qu)e|(ge|af|no|ca)r|p(o[br]|ap)|s[np]a|d(an|ut)|gsw|(fi|hu)n|'
    west_rx+='i(nd|ta)|a(rg|st)|baq|grn|l(at|tz)|mlg|n(ah|ds|no|ob)|orm|t(up|pi)|xho|zul|cp[efp])$'
    
    printf "\033[2;3;33mGuessing the charset used in '${1##*/}' ...\033[0;0m\n"
    if [[ "$2" =~ $west_rx ]]; then SUB_CS_="WINDOWS-1252" # western latin
    elif [[ "$2" =~ ^(ara|per|fas|urd)$ ]]; then SUB_CS_="WINDOWS-1256" # arabic
    elif [[ "$2" =~ ^(cze|pol|rum|h(rv|un)|sl[ov]|bos)$ ]]; then SUB_CS_="WINDOWS-1250" # eastern-european
    elif [[ "$2" =~ ^(rus|bul|arm|kaz|mac)$ ]]; then SUB_CS_="WINDOWS-1251" # cyrillic
    elif [[ "$2" == kor ]]; then SUB_CS_="EUC-KR" # korean
    elif [[ "$2" == vie ]]; then SUB_CS_="WINDOWS-1258" # vietnamese
    elif [[ "$2" == tur ]]; then SUB_CS_="WINDOWS-1254" # turkish
    elif [[ "$2" == tha ]]; then SUB_CS_="WINDOWS-874" # thai
    elif [[ "$2" =~ ^(gr[ec]|ell)$ ]]; then SUB_CS_="WINDOWS-1253" # greek
    elif [[ "$2" =~ ^(heb|yid)$ ]]; then SUB_CS_="WINDOWS-1255" # hebrew
    #elif [[ "$2" =~ ^(l(av|it))$ ]]; then local SUB_CS_="WINDOWS-1257" # baltic :: 1250 vs 1257
    #elif [[ "$2" == chi ]]; then SUB_CS_="BIG5" # chinese :: BIG5 vs GBK vs 936
    # devanagari
    # est :: 1252 vs 1257 
    # srp :: 1250 vs 1251
    # swa :: 1252 vs 1256
    # ukr :: 1252 vs 1251
    else TO_UTF8_STATUS_="bad"; fi

    local out
    if [[ "$TEST_MODE_" == false ]]; then
        if out=$(iconv -f "$SUB_CS_" -t UTF8 "$1" -o "/tmp/nicemkv_${1##*/}.utf8" 2>&1); then
            PREVIOUS__LINES_+="iconv -f \"$SUB_CS_\" -t UTF8 \"$1\" -o \"/tmp/nicemkv_${1##*/}.utf8\"; "
            OPS_OUT_+="$out"
        else
            cp -L -u "$1" "/tmp/nicemkv_${1##*/}.utf8" &> /dev/null
            if out=$(recode "${SUB_CS_,,}"..UTF-8 "/tmp/nicemkv_${1##*/}.utf8" 2>&1); then
                PREVIOUS__LINES_+="cp -L -u \"$1\" \"/tmp/nicemkv_${1##*/}.utf8\"; "
                PREVIOUS__LINES_+="recode \"${SUB_CS_,,}\"..UTF-8 \"/tmp/nicemkv_${1##*/}.utf8\"; "
                OPS_OUT_+="$out"
            else 
                rm -f "/tmp/nicemkv_${1##*/}.utf8" &> /dev/null; TO_UTF8_STATUS_="bad"
                fi
            fi
        fi

    if [[ "$TO_UTF8_STATUS_" == "bad" ]]; then
        error warning "Something went wrong while converting '$1' to UTF8 or guessing its charset\n"
        fi
}

# Iterates over the audio tracks of a file, storing information about them on global variables
iterate_over_audios ()
{
    for i in `seq 1 20`; do
        AUDIO_INFO_=$(mediainfo "$INPUT_" | \
                sed -n '/^Audio #'$i'[^[:graph:]]*$/,/^Audio #'$((i+1))'[^[:graph:]]*$/p')
        if [[ $(echo "$AUDIO_INFO_" | wc -c) -lt 8 ]]; then break; fi
        AUDIO_TRACK_=$(echo "$AUDIO_INFO_" | grep -m1 '^ID' | \
                sed -r 's/^.*:[\t ]+([[:digit:]]{1,2})[^[:graph:]]*$/\1/')
        AUDIO_TRACK_=$((AUDIO_TRACK_ - 1))
        AUDIO_COD_=$(echo -n "$AUDIO_INFO_" | grep -m1 '^[Ff]ormat' | sed -r 's/^.*:[\t ]+(.*)$/\1/')
        AUDIO_COD_="${AUDIO_COD_//[-_]}"
        AUDIO_CHA_=$(echo -n "$AUDIO_INFO_" | grep -m1 -E '^[Cc]hannel(s|.s.)' | \
                sed -r 's/^.*:[\t ]+([[:digit:]]+).*$/\1/')
        AUDIO_BR_=$(echo -n "$AUDIO_INFO_" | grep -E -m1 '^[Bb]it.?[Rr]ate[\t ]+:' | \
                sed -r 's/^.*:[\t ]+(.*)$/\1/')
        if [[ "$AUDIO_BR_" == "" ]]; then AUDIO_BR_="? Kbps"; fi
        AUDIO_SIZE_=$(echo -n "$AUDIO_INFO_" | grep -E -m1 '^[Ss]tream.?[Ss]ize' | sed -r 's/^.*:[\t ]+(.*)$/\1/')
        if [[ "$AUDIO_SIZE_" == "" ]]; then AUDIO_SIZE_="? B (?%)"; fi
        buffer=$(echo "$AUDIO_INFO_" | grep -m1 '^Language' | sed -r 's/^.*:[\t ]*([[:alpha:]]+)[^[:graph:]]*$/\1/')
        if [[ "$buffer" == "" ]]; then buffer="Undefined"; fi
        printf "\033[2m$AUDIO_TRACK_\t<$buffer>, <$AUDIO_COD_>, "
        echo -n "<$AUDIO_CHA_ channels>, <$AUDIO_BR_>, <$AUDIO_SIZE_>"
        ALL_AUDIO_LANGS_[$AUDIO_TRACK_]=$(lang_code "$buffer"); ALL_AUDIO_BRS_[$AUDIO_TRACK_]="$AUDIO_BR_"
        ALL_AUDIO_CODS_[$AUDIO_TRACK_]="$AUDIO_COD_"; ALL_AUDIO_CHAS_[$AUDIO_TRACK_]="$AUDIO_CHA_"
        if ! [[ ( "${buffer,,}" == "${AUDIO_LANG_,,}" ) || \
                ( "${ALL_AUDIO_LANGS_[AUDIO_TRACK_]}" == "${AUDIO_LANG_,,}" ) ]]; then
            AUDIO_TRACK_="NULL"
        elif [[ "$MANY_AUDIOS_SAME_LANG_" == false ]]; then
            printf "\n\t\033[7;33m[selected, based on language]\n"; OLD_AUDIO_LANG_="${AUDIO_LANG_,,}"; break
            fi
        printf "\n\033[2m"
        done
}

# Prints the name of the "subtitles codec" used in the given file
subtitles_codec ()
{
    local -r srt_time_rx='(([[:digit:]]{2}:){2}[[:digit:]]{2},[[:digit:]]{3}( --> )?){2}'
    local first_line=$(head -n1 "$1" | sed -r 's/^(\xEF\xBB\xBF|\xEF\xBB\xBF)//')
    if [[ "$first_line" == "<SAMI>"* ]]; then printf "SAMI"
    elif [[ "$first_line" == "WEBVTT"* ]]; then printf "WebVTT"
    elif [[ $(head -n8 "$1" | grep -Ec "$srt_time_rx") -gt 0 ]]; then printf "SubRip"
    elif [[ $(grep -Ec '^\[[Vv]4\+ [Ss]tyles\][^[:graph:]]*$' "$1") -eq 1 ]]; then printf "ASS"
    elif [[ $(grep -Ec '^\[[Vv]4 [Ss]tyles\][^[:graph:]]*$' "$1") -eq 1 ]]; then printf "SSA"
    elif [[ $(grep -Ec '^(\{[[:digit:]]+\}){2}.*$' "$1") -gt 1 ]]; then printf "MicroDVD"
    else printf "???"; fi
}

# SETTING THE DEFAULT VALUES OF THE MAIN VARIABLES
TEST_MODE_=false
INPUT_=""
FILENAME_AS_TITLE_=false
RENAME_ONLY_=false
REMOVE_REPLACE_=false
REMOVE_ALL_=false
ADD_SUBTITLES_=false
INHERIT_SUBS_="-S"
AUDIO_SOURCE_=""
AAC_AUDIO_=false
AAC_SETTINGS_=""
COVER_IS_THUMB_=false
COVER_FILE_=""
AUDIO_TRACK_=""
SUB_TRACKS_=""
SUB_EXTRA_OPTIONS_=""
ATTACH_OPTIONS_="--no-attachments"
V_LIB_OVER_CODEC_=false
VIDEO_LANG_=""
AUDIO_LANG_=""
TRACK_0_="--language 0:LANGCODE --default-track 0:yes --forced-track 0:yes"
TRACK_1_="--language TRKN:LANGCODE --default-track TRKN:yes --forced-track TRKN:yes"
COVER_="--attachment-mime-type image/jpeg --attachment-name cover.jpg --attach-file 'FILE'"
PREVIOUS__LINES_=""
FINAL_LOWLEVEL_CL_=""

# ABORTING IF 'mkvmerge' IS MISSING
if ! hash mkvmerge &> /dev/null; then error critical "mkvmerge is missing...\n" 100; fi

# PROCESSING THE COMMAND LINE
i=1; j=0; while [[ $i -le $# ]]; do
    buffer="${!i}"
    if [[ "$buffer" =~ ^-(h|-?help)$ ]]; then help_message full
    elif [[ "$buffer" =~ ^-(hl|-list-languages)$ ]]; then help_message languages
    elif [[ "$buffer" =~ ^-(\?|-get-command-line)$ ]]; then TEST_MODE_=true
    elif [[ "$buffer" =~ ^--?prepare$ ]]; then install_me dependencies
    elif [[ "$buffer" =~ ^--?install$ ]]; then install_me full
    elif [[ "$buffer" =~ ^-(i|-input)$ ]]; then 
        if [[ "$INPUT_" == "" ]]; then i=$((i + 1)); INPUT_="${!i}"; fi
    elif [[ "$buffer" =~ ^-(o|-output)$ ]]; then i=$((i + 1)); OUTPUT_="${!i}"
    elif [[ "$buffer" =~ ^-(O|-default-output)$ ]]; then OUTPUT_="predefined"
    elif [[ "$buffer" =~ ^-(n|-rename-to-default)$ ]]; then OUTPUT_="predefined"; RENAME_ONLY_=true
    elif [[ "$buffer" =~ ^-(r|-remove-input-file)$ ]]; then REMOVE_REPLACE_=true
    elif [[ "$buffer" == '-e' ]]; then V_LIB_OVER_CODEC_=true
    elif [[ "$buffer" =~ ^-(R|-remove-all-inputs)$ ]]; then REMOVE_REPLACE_=true; REMOVE_ALL_=true
    elif [[ "$buffer" =~ ^-(S|-inherit-subtitles)$ ]]; then INHERIT_SUBS_=""
    elif [[ "$buffer" =~ ^-(s|-subtitles)$ ]]; then
        i=$((i + 1))
        ADD_SUBTITLES_=true
        SUB_LIST_[j]="${!i}"
        j=$((j + 1))
    elif [[ "$buffer" =~ ^-(t|-title)$ ]]; then i=$((i + 1)); TITLE_="${!i}"
    elif [[ "$buffer" =~ ^-(T|-filename-as-title)$ ]]; then FILENAME_AS_TITLE_=true
    elif [[ "$buffer" =~ ^-(c|-cover)$ ]]; then i=$((i + 1)); COVER_FILE_="${!i}"
    elif [[ "$buffer" =~ ^-(L|-video-language)$ ]]; then i=$((i + 1)); VIDEO_LANG_=$(lang_code "${!i}")
    elif [[ "$buffer" =~ ^-(l|-audio-language)$ ]]; then i=$((i + 1)); AUDIO_LANG_=$(lang_code "${!i}")
    elif [[ "$buffer" =~ ^-(a|-audio-file)$ ]]; then i=$((i + 1)); AUDIO_SOURCE_="${!i}"
    elif [[ "$buffer" =~ ^-(A|-aac-audio)$ ]]; then AAC_AUDIO_=true; i=$((i + 1)); AAC_SETTINGS_="${!i}"
    else
        if ! [[ ( -f "$buffer" ) && ( -r "$buffer" ) ]]; then printf "'$buffer' is not a valid file...\n"
        elif [[ ( $(xdg-mime query filetype "$buffer") == image* ) && ( "$COVER_FILE_" == "" ) ]]; then
            COVER_FILE_="$buffer"
        elif [[ ( $(xdg-mime query filetype "$buffer") == video* ) && ( "$INPUT_" == "" ) ]]; then
            INPUT_="$buffer"
        elif [[ ( $(xdg-mime query filetype "$buffer") == audio* ) && ( "$AUDIO_SOURCE_" == "" ) ]]; then
            AUDIO_SOURCE_="$buffer"
        elif [[ "$buffer" =~ ^.*\.(s(sa|rt|a?mi)|ass)$ ]]; then
            ADD_SUBTITLES_=true
            SUB_LIST_[j]="$buffer"
            j=$((j + 1))
        elif [[ "$INPUT_" == "" ]]; then INPUT_="$buffer"; fi
        fi
    i=$((i + 1))
    done
printf "\n------------------------------------------ ----- ---- --- -- -\n\n"

# ABORTING IF 'ffmpeg' IS MISSING AND SEEMS TO BE NEEDED
if ! hash ffmpeg &> /dev/null && \
        [[ $(grep -Ec '\.(s(a?mi|ub|sa)|(as|mk)s)' <<< ${SUB_LIST_[@],,}) -gt 0 ]] || 
        [[ "$AAC_AUDIO_" == true ]]; then
    error critical "ffmpeg is missing...\n" 101
    fi

# ABORTING IF 'imagemagick' IS MISSING AND SEEMS TO BE NEEDED
if ! hash convert &> /dev/null && [[ -f "$COVER_FILE_" ]]; then
    error critical "imagemagick is missing...\n" 102
    fi

# CHECKING THE INPUT AUDIO/VIDEO AND ANALYZING ITS CONTENT
if [[ ( "$INPUT_" == "" ) || !( -f "$INPUT_" ) || !( -r "$INPUT_" ) ]]; then 
    printf "Input file is missing or was not specified\n"
    help_message
else
    if [[ "$AUDIO_SOURCE_" == "" ]]; then AUDIO_SOURCE_="$INPUT_"; fi
    if ! hash mediainfo &> /dev/null; then 
        error critical "mediainfo is missing...\n" 103
    elif [[ $(mediainfo --language=raw "$INPUT_" | grep -Ec '^[Vv]ideo[\t ]+#[^:]*$') -gt 1 ]]; then
        error critical "There are multiple video tracks in the input file...\n" 10
    elif [[ ( -f "$NEW_AUDIO_" ) && ( $(mediainfo --language=raw "$INPUT_" | grep -Ec '^[Aa]udio[\t ]+#[^:]*$') -gt 1 ) ]]; then
        error critical "There are multiple video tracks in the input file...\n" 10
    elif [[ $(mediainfo --language=raw "$INPUT_" | grep -Ec '^[Aa]udio[\t ]+#[^:]*$') -gt 1 ]]; then
        error warning "There are multiple audio tracks in the input file: \033[2;33m\nID\tdetails...\n"
        if [[ "#TODO" == "#TODO" ]]; then MANY_AUDIOS_SAME_LANG_=false; fi
        iterate_over_audios
        if [[ "$AUDIO_TRACK_" == "NULL" ]]; then
            printf "\n\033[2;33m"; read -p "Which one is to be kept? [ID] " AUDIO_TRACK_
            AUDIO_COD_="${ALL_AUDIO_CODS_[AUDIO_TRACK_]}"; AUDIO_BR_="${ALL_AUDIO_BRS_[AUDIO_TRACK_]}"
            AUDIO_CHA_="${ALL_AUDIO_CHAS_[AUDIO_TRACK_]}"; OLD_AUDIO_LANG_="${ALL_AUDIO_LANGS_[AUDIO_TRACK_],,}"
            fi
        printf "\033[0m\n"
    else
        AUDIO_TRACK_=1
        AUDIO_COD_=$(mediainfo --language=raw --full --inform="Audio;%Codec/Family%" "$INPUT_")
        if [[ "$AUDIO_COD_" =~ ^[^[:graph:]]*$ ]]; then 
            AUDIO_COD_=$(mediainfo --language=raw --full --inform="Audio;%Format%" "$INPUT_")
            fi
        AUDIO_COD_="${AUDIO_COD_//[-_]}"
        AUDIO_CHA_=$(mediainfo --language=raw --full --inform="Audio;%Channel(s)%" "$INPUT_")
        OLD_AUDIO_LANG_=$(mediainfo --language=raw --full --inform="Audio;%Language/String3%" "$INPUT_")
        fi
    TRACK_1_="${TRACK_1_//TRKN/$AUDIO_TRACK_}"
    if [[ "$V_LIB_OVER_CODEC_" == false ]]; then
        VIDEO_COD_=$(mediainfo --language=raw --full --inform="Video;%Codec/Family%" "$INPUT_")
    else VIDEO_COD_=$(mediainfo --language=raw --full --inform="Video;%Encoded_Library_Name%" "$INPUT_"); fi
    if [[ "$VIDEO_COD_" =~ ^[^[:graph:]]*$ ]]; then 
        VIDEO_COD_=$(mediainfo --language=raw --full --inform="Video;%Format%" "$INPUT_")
        fi
    VIDEO_COD_="${VIDEO_COD_//[-_]}"
    VIDEO_BR_=$(mediainfo --language=raw --full --inform="Video;%BitRate/String%" "$INPUT_")
    VIDEO_ASPECT_=$(mediainfo --language=raw --full --inform="Video;%DisplayAspectRatio/String%" "$INPUT_")
    VIDEO_FPS_=$(mediainfo --language=raw --full --inform="Video;%FrameRate%" "$INPUT_")
    RESOLUTION_=$(mediainfo --language=raw --full --inform="Video;%Height%" "$INPUT_")
    if [[ $RESOLUTION_ -gt 2000 ]]; then RESOLUTION_="4K";
    elif [[ $RESOLUTION_ -gt 800 ]]; then RESOLUTION_="1080p"
    elif [[ $RESOLUTION_ -gt 500 ]]; then RESOLUTION_="720p"
    elif [[ $RESOLUTION_ -gt 380 ]]; then RESOLUTION_="480p"
    elif [[ $RESOLUTION_ -gt 250 ]]; then RESOLUTION_="360p"
    else RESOLUTION_="240p"; fi
    fi

# INHERITING AUDIO/VIDEO LANGUAGES IF NO ONE WAS SPECIFIED BY THE USER, BUT ONE WAS IN THE INPUT FILE
if [[ "$AUDIO_LANG_" =~ ^([Uu][Nn][Dd].*|[^[:graph:]]*)$ ]]; then 
    if [[ "$OLD_AUDIO_LANG_" =~ ^([Uu][Nn][Dd].*|[^[:graph:]]*)$ ]]; then AUDIO_LANG_="und"
    else AUDIO_LANG_="$OLD_AUDIO_LANG_"; fi
    fi
if [[ "$VIDEO_LANG_" =~ ^([Uu][Nn][Dd].*|[^[:graph:]]*)$ ]]; then
    buffer=$(mediainfo --full --language=raw --inform="Video;%Language/String3%" "$INPUT_")
    if [[ "$buffer" =~ ^[[:alpha:]]{3}$ ]]; then VIDEO_LANG_="${buffer,,}"
    else VIDEO_LANG_="und"; fi
    fi

# SETTING (OR PROMPTING FOR) A TITLE (METADATA) IF NONE WAS SET PREVIOUSLY
if [[ ( "$TITLE_" == "" ) && ( "$FILENAME_AS_TITLE_" == true ) ]]; then
    TITLE_=$(printf "${INPUT_##*/}\n" | sed -r 's/^(.*?)\.[[:alnum:]]{1,4}$/\1/')
    fi
if [[ "$INPUT_" == *.mkv ]]; then
    OLD_TITLE_=$(mkvinfo "$INPUT_" | grep [Tt]itle | sed -r 's/^.*?: (.*)$/\1/')
    if [[ "$TITLE_" == "" ]]; then TITLE_="$OLD_TITLE_"; fi
    fi
if [[ "$TITLE_" == "" ]]; then
    read -p "Do you want to enter a title for the file now? [Y/n] " buffer
    if [[ "$buffer" == [Nn]* ]]; then TITLE_="${INPUT_##*/}"; TITLE_="${TITLE_%%.*}"
    else read -p "Title: " TITLE_; fi
    printf "\n"
    fi
OLD_TITLE_=$(printf "${OLD_TITLE_//%/%%}" | sed -n '1p')
TITLE_=$(printf "${TITLE_//%/%%}" | sed -n '1p')
TITLE_=$(echo ${TITLE_//<old_title>/$OLD_TITLE_})

# CHECKING THE OUTPUT PATH AND FIXING IT, IF NEEDED AND POSSIBLE
if [[ "$OUTPUT_" == "" ]]; then 
    OUTPUT_="${INPUT_%.*}.mkv"
    if [[ ( "$REMOVE_REPLACE_" == true ) && ( "$INPUT_" == "$OUTPUT_" ) ]]; then OUTPUT_="$OUTPUT_.tmp"; fi
elif [[ "$OUTPUT_" == "predefined" ]]; then
    if [[ "$INPUT_" == */* ]]; then OUTPUT_="${INPUT_%/*}/$TITLE_"
    else OUTPUT_="$TITLE_"; fi
    OUTPUT_="$OUTPUT_ $RESOLUTION_ $VIDEO_COD_ $AUDIO_COD_.mkv"
    if [[ "$RENAME_ONLY_" == true ]]; then FINAL_LOWLEVEL_CL_="mv -vi \"$INPUT_\" \"$OUTPUT_\"\n"; fi
elif [[ -d "$OUTPUT_" ]]; then
    buffer=${INPUT_##*/}
    OUTPUT_="${OUTPUT_%/}/${buffer%.*}.mkv"
elif [[ "$OUTPUT_" != *.mkv ]]; then
    OUTPUT_=$(printf "${OUTPUT_//%/%%}" | sed -r 's/\.[[:alnum:]]{1,4}/.mkv/')
    fi
if [[ "$OUTPUT_" == "$INPUT_" ]]; then
    printf "\nOutput would overwrite input...\nIf that is what you want, enable the '-r' (or '-R') option\n"
    exit 65
    fi

# PRINTING INPUT INFORMATION
printf "MAIN INPUT:\n\033[2m${INPUT_//%/%%}\033[0m\n"
printf "\033[2;3;7mVideo: $VIDEO_COD_ [$RESOLUTION_"
if [[ "$VIDEO_ASPECT_" != "" ]]; then printf ", $VIDEO_ASPECT_"; fi
if [[ "$VIDEO_FPS_" != "" ]]; then printf ", $VIDEO_FPS_ fps"; fi
if [[ "$VIDEO_BR_" != "" ]]; then printf ", $VIDEO_BR_"; fi
printf "]\033[0;0;0m\n"
if [[ "$AUDIO_SOURCE_" == "$INPUT_" ]]; then printf "\033[2;3;7mAudio: "
else printf "AUDIO:\n\033[2m${AUDIO_SOURCE_//%/%%}\033[0m\n\033[2;3;7m"; fi
printf "$AUDIO_COD_ [$AUDIO_CHA_ channels"
if [[ "$AUDIO_BR_" != "" ]]; then printf ", $AUDIO_BR_"; fi
printf ", ${OLD_AUDIO_LANG_,,}]\033[0;0;0m\n"

# DISCARDING ANY REMAINING TEMPORARY FILE BEFORE PONTENTIALLY CREATING NEW ONES
discard_tmps
rm -f "$INPUT.tmp" &> /dev/null

# PROCESSING ANY GIVEN SUBTITLES
if [[ "$j" -gt 0 ]]; then IFS=$'\n'; SUB_LIST_=($(sort -d -s <<< "${SUB_LIST_[*]}")); unset IFS; fi
if [[ "$ADD_SUBTITLES_" == true ]]; then
    printf "SUBTITLES:\n"
    i=0
    SUB_f=$(if [[ "$AAC_AUDIO_" == true ]]; then printf "2"; else printf "1"; fi)
    while [[ "$i" -lt "$j" ]]; do
        if ! [[ "${SUB_LIST_[i]}" =~ ^[[:alpha:]]{3}:.*$ ]]; then
            if [[ "${SUB_LIST_[i]}" =~ ^[[:alpha:]]{3,15}:.*$ ]]; then
                SUB_LANG_[i]=$(lang_code $(printf "${SUB_LIST_[i]//%/%%}" | \
                    sed -r 's/^([[:alpha:]]{3,15}):.*$/\1/'))
                fi
            if [[ "${SUB_LANG_[i]}" == "UND" ]] || \
                    [[ "${SUB_LIST_[i],,}" =~ ^.*[[:alpha:]]{3}\.(s(sa|rt|ub|a?mi)|ass)$ ]]; then
                SUB_LANG_[i]=$(lang_code $(printf "${SUB_LIST_[i]//%/%%}" | \
                    sed -r 's/^.*([[:alpha:]]{3})\....$/\1/'))
                fi
            if [[ "${SUB_LANG_[i]}" == "UND" ]]; then
                printf "\033[2;3;33m"; 
                read -p "Name (in english or ISO 639-2 code) the language of '${SUB_LIST_[i]##*/}': " buffer
                printf "\033[0;0;0m"
                SUB_LANG_[i]=$(lang_code "$buffer")
                SUB_LIST_[i]=$(printf "${SUB_LIST_[i]//%/%%}" | sed -r 's/^[[:alpha:]]{,12}://')
                fi
        else
            SUB_LANG_[i]=$(lang_code "${SUB_LIST_[i]:0:3}")
            SUB_LIST_[i]="${SUB_LIST_[i]:4}"
            fi
        
        if [[ "${SUB_LANG_[i]}" == "UND" ]]; then
            printf "Unrecognized language '${buffer//%/%%}'\n"
            printf "Try '${0##*/} -hl' for a list of accepted languages and codes\n"
            exit 95
            fi
        SUB_COD_=$(subtitles_codec "${SUB_LIST_[i]}")
        if ! [[ "${SUB_LIST_[i]}" == *.srt ]]; then
            if [[ "$TEST_MODE_" == true ]]; then
                PREVIOUS__LINES_+="ffmpeg -i \"${SUB_LIST_[i]}\" -vn -an "
                PREVIOUS__LINES_+="-scodec srt \"/tmp/${SUB_LIST_[i]##*/}.srt.utf8\"; "
            elif OPS_OUT_+=$(ffmpeg -v 40 -hide_banner -i "${SUB_LIST_[i]}" -vn -an -scodec srt \
                        "/tmp/${SUB_LIST_[i]##*/}.srt.utf8" 2>&1; printf "\n"); then
                OLD_SUB_LIST[i]="${SUB_LIST_[i]}"
                SUB_LIST_[i]="/tmp/${SUB_LIST_[i]##*/}.srt.utf8"
            else 
                error critical "'${SUB_LIST_[i]}' contains no valid subtitles\n" 31
                fi
            fi
        to_utf8 "${SUB_LIST_[i]}" "${SUB_LANG_[i]}"
        if [[ "$REMOVE_ALL_" == true ]]; then OLD_SUB_LIST_[i]="${SUB_LIST_[i]}"; fi
        if [[ ( -f "/tmp/nicemkv_${SUB_LIST_[i]##*/}.utf8" ) && ( "$TO_UTF8_STATUS" != bad ) ]]; then
            SUB_LIST_[i]="/tmp/nicemkv_${SUB_LIST_[i]##*/}.utf8"
            fi
        if [[ -f "${SUB_LIST_[i]}" ]]; then
            printf "\033[2m${SUB_LIST_[i]//%/%%}\n\033[2;3;7m${SUB_CS_//[-_]} $SUB_COD_ [${SUB_LANG_[i]}]\033[0;0;0m"
            if [[ $(printf "${SUB_LIST_[i]//%/%%}" | grep -Ec '^(.*[^[:alpha:]])?(SDH|sdh)([^[:alpha:]].*)?$') -gt 0 ]]; then
                SUB_EXTRA_OPTIONS_+=" --track-name 0:'SDH'"
                printf "\033[2;3;7m [SDH]\033[0;0;0m"
                fi
            printf "\033[0m\n"
            SUB_EXTRA_OPTIONS_+=" --language 0:${SUB_LANG_[i]} --sub-charset 0:UTF-8"
            SUB_EXTRA_OPTIONS_+=" --default-track 0:no --forced-track 0:no"
            SUB_EXTRA_OPTIONS_+=" --subtitle-tracks 0 '(' \"${SUB_LIST_[i]}\" ')'"
            SUB_TRACKS_=",$SUB_f:0"
            fi
        i=$((i + 1))
        SUB_f=$((SUB_f + 1))
        done
    SUB_EXTRA_OPTIONS_="${SUB_EXTRA_OPTIONS_# }"
    fi

# PROCESSING ANY GIVEN COVER IMAGE
if [[ "$COVER_FILE_" != "" ]]; then 
    if ! [[ ( -f "$COVER_FILE_" ) && ( -r "$COVER_FILE_" ) ]]; then
        if wget -O "$COVER_FILE_" -c "/tmp/nicemkv.cover.jpg"; then
            PREVIOUS__LINES_+="wget -O \"$COVER_FILE_\" -c \"/tmp/nicemkv.cover.jpg\""
            COVER_FILE_="/tmp/nicemkv.cover.jpg"
        else 
            error critical "Cannot access '$2'\n" 29
            fi
        fi
    if [[ $(xdg-mime query filetype "$COVER_FILE_") =~ ^image/.*$ ]]; then
        COVER_COD_=$(identify -format '%m' "$COVER_FILE_")
    else COVER_COD_="???"; fi
    if [[ $(xdg-mime query filetype "$COVER_FILE_") != 'image/jpeg'* ]]; then
        convert "$COVER_FILE_" -format jpeg -quality 99 "/tmp/nicemkv.cover.jpg"
        PREVIOUS__LINES_+="convert \"$COVER_FILE_\" -format jpeg -quality 99 \"/tmp/nicemkv.cover.jpg\""
        if [[ $? -ne 0 ]]; then
            error critical "'$2' is not a valid image file\n" 20
            fi
        OLD_COVER_FILE_="$COVER_FILE_"
        COVER_FILE_="/tmp/nicemkv.cover.jpg"
        fi
    COVER_WIDTH=$(identify -ping -format '%W\n%H' "$COVER_FILE_" | sed '1q;d')
    COVER_HEIGHT=$(identify -ping -format '%W\n%H' "$COVER_FILE_" | sed '2q;d')
    COVER_IS_POSTER=$(((COVER_HEIGHT * 200) / (COVER_WIDTH / 5)))
    if [[ ( "$COVER_IS_POSTER" -ge 1490 ) && ( "$COVER_IS_POSTER" -le 1510 ) ]]; then
        if [[ ( "$COVER_WIDTH" -ge 595 ) && ( "$COVER_HEIGHT" -ge 893 ) ]]; then
            if [[ "$COVER_FILE_" == "/tmp/nicemkv.cover.jpg" ]]; then
                convert "$COVER_FILE_" -resize 600x900\! "$COVER_FILE_" 
            else
                convert "$COVER_FILE_" -resize 600x900\! "/tmp/nicemkv.cover.jpg"
                OLD_COVER_FILE_="$COVER_FILE_"
                COVER_FILE_="/tmp/nicemkv.cover.jpg"
                fi
        else
            printf "The cover seems to be a movie poster, but it is too small...\n"
            read -p "Proceed anyway? [y/N] " buffer
            if [[ "$buffer" != [Yy]* ]]; then exit 11; fi
            fi
        fi
else
    if [[ ( "$INPUT_" == *.mkv ) && ( $(mkvinfo "$INPUT_" | grep -Eic 'cover\.jpe?g') -eq 1 ) ]]; then
        ATTACH_OPTIONS_=$(mkvinfo "$INPUT_" | sed -r -n '1,/.*[Cc][Oo][Vv][Ee][Rr]\.[Jj][Pp][Ee]?[Gg].*/p' | \
                    grep -c -i 'attached')
        ATTACH_OPTIONS_="--attachments $ATTACH_OPTIONS_"
        COVER_=""
    else
        if ! hash totem-video-thumbnailer &> /dev/null; then 
            error warning "totem-video-thumbnailer is missing...\n"
            COVER_=""
        else
            OPS_OUT_+=$(totem-video-thumbnailer -j -v -s 600 -t 23 "$INPUT_" "/tmp/nicemkv.cover.jpg" \
                    2>&1; printf "\n")
            COVER_FILE_="/tmp/nicemkv.cover.jpg"
            COVER_IS_THUMB_=true
            fi
        fi
    fi
if [[ -f "$COVER_FILE_" ]]; then 
    COVER_FINAL_DIMS_=$(identify -ping -format '%Wx%H' "$COVER_FILE_")
    printf "COVER IMAGE:\n\033[2m"
    if [[ "$COVER_IS_THUMB_" == false ]]; then 
        printf "${COVER_FILE_//%/%%}\n\033[3;7m$COVER_COD_ [${COVER_WIDTH}x$COVER_HEIGHT]"
    elif [[ "$COVER_IS_THUMB_" == "inherited" ]]; then
        printf "inherited"
    else 
        printf "thumbnail"
        fi
    printf "\033[0;0;0m\n"
    fi

# PRINTING OUTPUT INFORMATION
if [[ "$OUTPUT_" == "$INPUT_".tmp ]]; then printf "\nOUTPUT:\n\033[2m${INPUT_//%/%%}\033[0m\n"
else printf "\nOUTPUT:\n\033[2m$OUTPUT_\033[0m\n"; fi
if [[ "$AAC_AUDIO_" == true ]]; then printf "\033[2;3;7mAudio: AAC [$AUDIO_CHA_ channels"
else printf "\033[2;3;7mAudio: $AUDIO_COD_ [$AUDIO_CHA_ channels"; fi
printf ", ${AUDIO_LANG_,,}"
printf "]\033[0;0;0m\n"
printf "\033[2;3;7mVideo: $VIDEO_COD_ [$RESOLUTION_"
if [[ "$VIDEO_ASPECT_" != "" ]]; then printf ", $VIDEO_ASPECT_"; fi
if [[ "$VIDEO_FPS_" != "" ]]; then printf ", $VIDEO_FPS_ fps"; fi
if [[ "$VIDEO_BR_" != "" ]]; then printf ", $VIDEO_BR_"; fi
printf "]\033[0;0;0m\n"
if [[ ( "$INHERIT_SUBS_" == true ) && ( "${#SUB_LIST_[@]}" -lt 1 ) ]]; then
    printf "???"
else
    printf "\033[2;3;7mSubtitles: UTF8 SubRip ["
    if [[ "${#SUB_LANG_[@]}" -eq 0 ]]; then printf " "
    elif [[ "${#SUB_LANG_[@]}" -gt 13 ]]; then printf "${#SUB_LANG_[@]} languages"
    else for i in ${SUB_LANG_[@]}; do printf "$i "; done; fi
    printf "\b]\033[0;0;0m\n"
    if [[ "$INHERIT_SUBS_" == true ]]; then printf " + ???"; fi
    fi
printf "\033[2;3;7mCover Image: JPEG [$COVER_FINAL_DIMS_]\033[0;0;0m\n"
printf "\033[2;3;7mTitle: \"${TITLE_//%/%%}\"\033[0;0;0m\n"

# CONVERTING THE INPUT'S AUDIO TO AAC
if [[ ( "$AAC_AUDIO_" == true ) && ( "$AUDIO_COD" != "AAC"* ) && ( "$RENAME_ONLY_" == false ) ]]; then
    if [[ "$AAC_SETTINGS_" =~ ^(([[:digit:]]{2,5}k|[[:digit:]]{1,2}M)(b(its?)?([p/]s(ec)?)?)?|([Vv][Bb][Rr]|~)[1-5])$ ]]; then
        if [[ "$AAC_SETTINGS" =~ ^[Vv][Bb][Rr].* ]]; then AAC_QUALITY_="-vbr ${AAC_SETTINGS_:3:1}"
        elif [[ "$AAC_SETTINGS" =~ ^~.* ]]; then AAC_QUALITY_="-vbr ${AAC_SETTINGS_:1:1}"
        else AAC_QUALITY_="-ab ${AAC_SETTINGS_//[^[:digit:]kM]//}"; fi
    else
        error critical "Invalid AAC audio track specification '$AAC_SETTINGS'\n" 50
        fi
    if ! [[ -e '/usr/include/fdk-aac/aacenc_lib.h' ]]; then 
        error critical "libfdk-aac-dev is missing...\n" 51
        fi
    if [[ "$TEST_MODE_" == true ]]; then 
        printf "\nffmpeg -v quiet -hide-banner -i \"${INPUT_//%/%%}\" -vn -sn -acodec libfdk_aac -ac $AUDIO_CHA_ $AAC_QUALITY_ \"${INPUT_%.*}.aac\"\n"
    elif ! ffmpeg -v quiet -hide-banner -i "$INPUT_" -vn -sn -acodec libfdk_aac -ac $AUDIO_CHA_ $AAC_QUALITY_ "${INPUT_%.*}.aac"; then
        AAC_AUDIO_=false
        TRACK_1_="$TRACK_0_"
        error critical "Failed to convert input audio to AAC...\n" 51
        fi
    fi

# CLEANING THE COVER IMAGE BEFORE USING IT, IF ONE EXISTS
if [[ -f "$COVER_FILE_" ]] && \
        [[ ( "$COVER_FILE_" =~ ^.*\.[Jj][Pp][Ee]?[Gg]$ ) && ( "$RENAME_ONLY_" == false ) ]]; then
    FINAL_LOWLEVEL_CL_+="jpegoptim --strip-all \"$COVER_FILE_\"; mat \"$COVER_FILE_\"; "
    fi

# CONSTRUCTING THE 'mkvmerge' COMMAND LINE
if [[ "$RENAME_ONLY_" == false ]]; then
if [[ "$AAC_AUDIO_" == true ]]; then FINAL_LOWLEVEL_CL_+="mkvmerge -v --output \"$OUTPUT_\" ${TRACK_0_/LANGCODE/${VIDEO_LANG_}} --no-audio-tracks --no-track-tags --no-global-tags $ATTACH_OPTIONS_ --video-tracks 0 -T $INHERIT_SUBS_ '(' \"$INPUT_\" ')' ${TRACK_1_/LANGCODE/${AUDIO_LANG_}} --no-video-tracks --no-track-tags --no-global-tags --no-chapters --no-buttons --audio-tracks $AUDIO_TRACK_ -T -S '(' \"${INPUT_%.*}.aac\" ')' $SUB_EXTRA_OPTIONS_ --track-order \"0:0,1:$AUDIO_TRACK_$SUB_TRACKS_\" ${COVER_//FILE/${COVER_FILE_}} --title \"$TITLE_\" ; rm -f \"${INPUT_%.*}.aac\""
else FINAL_LOWLEVEL_CL_+="mkvmerge -v --output \"$OUTPUT_\" ${TRACK_0_/LANGCODE/${VIDEO_LANG_}} ${TRACK_1_/LANGCODE/${AUDIO_LANG_}} --no-track-tags --no-global-tags $ATTACH_OPTIONS_ --audio-tracks $AUDIO_TRACK_ --video-tracks 0 -T $INHERIT_SUBS_ '(' \"$INPUT_\" ')' $SUB_EXTRA_OPTIONS_ --track-order \"0:0,0:$AUDIO_TRACK_$SUB_TRACKS_\" ${COVER_//FILE/${COVER_FILE_}} --title \"$TITLE_\""; fi
fi

# RUNNING OR PRINTING THE FINAL COMMAND LINE AND REMOVING FILES AS NEEDED OR WANTED
printf "\n------------------------------------------ ----- ---- --- -- -\n\n"
if [[ "$TEST_MODE_" == false ]]; then 
    printf "${OPS_OUT_//%/%%}\n"
    bash -c "$FINAL_LOWLEVEL_CL_"
    discard_tmps
    if [[ $? -ne 0 ]]; then 
        exit 1
    elif [[ "$REMOVE_ALL_" == true ]]; then
        rm -f "$INPUT_" &> /dev/null
        if [[ "$OUTPUT_" == "$INPUT_.tmp" ]]; then mv -f "$OUTPUT_" "$INPUT_" &> /dev/null; fi
        if [[ "$ADD_SUBTITLES_" == true ]]; then
            for i in `seq 0 $((j - 1))`; do    
                rm -f "${SUB_LIST_[i]}" &> /dev/null
                rm -f "${OLD_SUB_LIST_[i]}" &> /dev/null
                done
            fi
        if [[ "$COVER_FILE_" == "/tmp/nicemkv.cover.jpg" ]]; then rm -f "$OLD_COVER_FILE_" &> /dev/null
        elif [[ -f "$COVER_FILE_" ]]; then rm -f "$COVER_FILE_" &> /dev/null; fi
        if [[ -f "$AUDIO_SOURCE_" ]]; then rm -f "$AUDIO_SOURCE_" &> /dev/null; fi
    elif [[ "$REMOVE_REPLACE_" == true ]]; then
        rm -f "$INPUT_" &> /dev/null
        if [[ "$OUTPUT_" == "$INPUT_.tmp" ]]; then mv -f "$OUTPUT_" "$INPUT_" &> /dev/null; fi
        fi
else 
    printf "GENERATED LOW-LEVEL COMMAND LINE:\n"
    printf "\033[3;2;36m${PREVIOUS__LINES_//%/%%}\n\033[0;0;36m${FINAL_LOWLEVEL_CL_//%/%%}\033[0m\n\n"
    discard_tmps
    fi

###############################################################################################
exit
###############################################################################################

#convert audio to aac
#take other audio input
#multiple audio tracks - same language
#convert original cover to jpg 600x900
#to_utf8 - finish
#deal with mks / vobsub / pol.txt
#sort ALL subtitles by language
#convert original subtitles to subrip utf8
#subtitles info for input
#cover info for input
#put image manipulation on final cl
#original cover.png / cover.gif / cover.bmp
#output cover info for inherited cover
#remove track names :: ?
# --aac-is-sbr <TID[:0|1]> The track with the ID is HE-AAC/AAC+/SBR-AAC or not. The value ':1' can be omitted.

"Options for each input file:
  -a, --audio-tracks <n,m,...>
                           Copy audio tracks n,m etc. Default: copy all
                           audio tracks.
  -A, --no-audio           Don't copy any audio track from this file.
  -d, --video-tracks <n,m,...>
                           Copy video tracks n,m etc. Default: copy all
                           video tracks.
  -D, --no-video           Don't copy any video track from this file.
  -s, --subtitle-tracks <n,m,...>
                           Copy subtitle tracks n,m etc. Default: copy
                           all subtitle tracks.
  -b, --button-tracks <n,m,...>
                           Copy buttons tracks n,m etc. Default: copy
                           all buttons tracks.
  -B, --no-buttons         Don't copy any buttons track from this file.
  -m, --attachments <n[:all|first],m[:all|first],...>
                           Copy the attachments with the IDs n, m etc to
                           all or only the first output file. Default: copy
                           all attachments to all output files.
  -M, --no-attachments     Don't copy attachments from a source file.
  -t, --tags <TID:file>    Read tags for the track from a XML file.
  --track-tags <n,m,...>   Copy the tags for tracks n,m etc. Default: copy
                           tags for all tracks.
  -T, --no-track-tags      Don't copy tags for tracks from the source file.
  --no-global-tags         Don't keep global tags from the source file.
  --no-chapters            Don't keep chapters from the source file.
  -y, --sync <TID:d[,o[/p]]>
                           Synchronize, adjust the track's timecodes with
                           the id TID by 'd' ms.
                           'o/p': Adjust the timecodes by multiplying with
                           'o/p' to fix linear drifts. 'p' defaults to
                           1 if omitted. Both 'o' and 'p' can be
                           floating point numbers.
  --default-track <TID[:bool]>
                           Sets the 'default' flag for this track or
                           forces it not to be present if bool is 0.
  --forced-track <TID[:bool]>
                           Sets the 'forced' flag for this track or
                           forces it not to be present if bool is 0.
  --blockadd <TID:x>       Sets the max number of block additional
                           levels for this track.
  --track-name <TID:name>  Sets the name for a track.
  --cues <TID:none|iframes|all>
                           Create cue (index) entries for this track:
                           None at all, only for I frames, for all.
  --language <TID:lang>    Sets the language for the track (ISO639-2
                           code, see --list-languages).
  --aac-is-sbr <TID[:0|1]> The track with the ID is HE-AAC/AAC+/SBR-AAC
                           or not. The value ':1' can be omitted.
  --timecodes <TID:file>   Read the timecodes to be used from a file.
  --default-duration <TID:Xs|ms|us|ns|fps>
                           Force the default duration of a track to X.
                           X can be a floating point number or a fraction.
  --fix-bitstream-timing-information <TID[:bool]>
                           Adjust the frame/field rate stored in the video
                           bitstream to match the track's default duration.
  --nalu-size-length <TID:n>
                           Force the NALU size length to n bytes with
                           2 <= n <= 4 with 4 being the default."


