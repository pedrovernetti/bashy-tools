#!/bin/bash

## Prints a help message
help_message ()
{
	printf "Usage: ${0##*/} [OPTIONS] -i INPUT_FILE [OPTIONS]\n\n"
	if [[ "$1" == "full" ]]; then
		printf "  Options:\n\n"
		printf "  -h        print this help message and exit\n"
		printf "  -hl       print the list of supported languages\n"
		printf "  -prepare  install dependencies (\033[1mmust be runned once\033[0m)\n"
		printf "  -?        print the low-level command lines which \033[1mwould be\033[0m called\n\n"
		printf "  -a        convert audio to AAC [#TODO]\n"
		printf "  -c \033[2mIMG\033[0m    embed 'IMG' to the output as its cover/thumbnail\n"
		printf "  -i \033[2mFILE\033[0m   take audio and video from 'FILE'\n"
		printf "  -L \033[2mLNG\033[0m    set 'LNG' as the video language\n"
		printf "  -l \033[2mLNG\033[0m    set 'LNG' as the audio language\n"
		printf "  -n        like '-O', but \033[1mnothing\033[0m is done other than renaming\n"
		printf "  -o \033[2mPATH\033[0m   save the generated output to 'PATH'\n"
		printf "  -O        name the output file according to its title\n"
		printf "  -R        remove every taken file (main input, subtitles and images)\n"
		printf "  -r        remove the input audio/video file (as set by '-i')\n"
		printf "  -s \033[2mLNG\033[0m:\033[2mST\033[0m embed subtitles from 'ST' in the output\n"
		printf "  -t \033[2mTITL\033[0m   set 'TITL' as the title (metadata) of the output\n\n"
		printf "  \033[1;30mFILE\033[0m must be a mkvtoolnix-supported audio/video file\n"
		printf "  \033[1;30mIMG\033[0m  must be a JPEG or any imagemagick-supported image file\n"
		printf "  \033[1;30mPATH\033[0m must be a valid file path to write a Matroska file to\n"
		printf "  \033[1;30mLNG\033[0m  must be the english name or the ISO 639-2B code of a language\n"
		printf "  \033[1;30mST\033[0m   must be a SubRip (.srt) or any ffmpeg-supported subtitles file\n"
		printf "  \033[1;30mTITL\033[0m can be any short piece of text\n\n" 
		printf "Non-JPEG cover images are converted to JPEG before being attached,\n"
		printf "as non-SubRip or non-UTF8 subtitles are all converted to UTF8 SubRip\n"
		printf "before being embedded.\n\n"
		printf "If a subtitles file is cleanly named after the ISO 639-2B code of its\n"
		printf "language, there is no need to make its language explicit in the options.\n\n"
		printf "Examples:\n\n\033[3m${0##*/} -c 'poster.jpg' -s english:'eng.srt' -i 'movie.mp4'\033[0m\n"
		printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named 'movie.mkv' with audio and video\n"
		printf "from 'movie.mp4', 'poster.jpg' as its thumbnail and\n"
		printf "embedded english subtitles extracted from 'eng.srt'.\033[0m\n\n"

		printf "\033[3m${0##*/} -t 'Trailer' -s 'eng.srt' -s 'ger.srt' -i 'trlr.mp4' -O\033[0m\n"
		printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named after its content (something like\n"
		printf "'Trailer 720p AVC AAC.mkv') with audio and video from\n"
		printf "'trlr.mp4', no specific thumbnail, 'Trailer' as its title\n"
		printf "and embedded english and german subtitles extracted from\n"
		printf "'eng.srt' and 'ger.srt', respectively.\033[0m\n\n"

		printf "\033[3m${0##*/} -l por -s eng:'sdh.srt' -i 'video.avi' -o 'out.mkv'\033[0m\n"
		printf "\033[2;32mcreates an \033[2;3;32m.mkv\033[0;2;32m named 'out.mkv' with audio and video\n"
		printf "from 'video.avi', portuguese as its audio language\n"
		printf "embedded english subtitles extracted from 'sdh.srt'.\033[0m\n"
	elif [[ "$1" == "languages" ]]; then
		printf "ISO 639-2B codes, plus english names for every supported\n"
		printf "language are listed below.\n"
		printf "\033[2mAny of these will be understood, but ISO 639-2B (the 3-letters code)\n"
		printf "is prefered, since it better avoids any ambiguity.\033[0m\n\n"
		printf " 639-3\t639-2\tenglish name\n\n"
		printf "$ISO639_REF\n" | sed -r \
			-e 's/^(.*)[[:space:]]+\|[[:space:]]+(...)[[:space:]]+\|(.*)$/ \2\t\3\t\1/;' \
			-e 's/^(.*\t.*\t.{50}).{4,}/\1.../' | sort | GREP_COLOR='01' egrep -i --color=always '^ ....'
	else
		exit 1
		fi
	printf "\n"
	exit 0
}

## Prints an error (then exits) or warning
error ()
{
	if [[ "$1" == [Ww]* ]]; then printf "\033[1;33m$2\033[0m"
	elif [[ "$1" == [Cc]* ]]; then printf "\033[1;31m$2\033[0m"; exit $3
	else printf "$2"; fi
}

## Installs what is previously needed to run this script
install_me ()
{
	printf "\033[1mDepencies will now be installed...\033[0m\n"
	sudo sed -i -r '/(mkvtoolnix|bunkus)/d' /etc/apt/sources.list
	buffer="deb http://mkvtoolnix.download/ubuntu/"$(lsb_release -sc)"/"
	sudo bash -c "printf \"\\n\\n$buffer ./\" >> /etc/apt/sources.list"
	sudo bash -c "printf \"\\n$buffer ./\" >> /etc/apt/sources.list"
	wget -q -O - https://mkvtoolnix.download/gpg-pub-moritzbunkus.txt | \
		sudo apt-key add -
	sudo apt-get update
	sudo apt-get install file grep sed iconv
	sudo apt-get install iso-codes mediainfo mkvtoolnix ffmpeg
	sudo apt-get install imagemagick jpegoptim mat
	if [[ "$1" == "full"  ]]; then sudo cp -uv "$0" /usr/bin/2nicemkv; fi
	exit 0
}

# EXTRACING THE MKVTOOLNIX LIST OF SUPPORTED LANGUAGES
if hash mkvmerge; then 
	declare -r ISO639_REF=$(mkvmerge --list-languages | \
				tr '[:upper:]' '[:lower:]' | \
				sed -r '1d;2d;/.*[^[:lower:] \t|;].*/d;s/[[:space:]]{2,}/ /g;'; \
				printf "greek | gre | el\nhebrew | heb |\n")
	fi

## Prints the proper ISO-639-3 code for a given language
lang_code ()
{
	local buffer=$(printf "$1" | tr '[:upper:]' '[:lower:]' | \
				sed -r 's/^([[:lower:]]{3})$/| \1 |/')
	local buffer=$(printf "$ISO639_REF" | grep "${buffer,,}" | \
			head -n1 | sed -r 's/^.*\| ?(...) ?\|.*$/\1/')
	if [[ "$buffer" == "" ]]; then printf "UND"
	else printf "$buffer"; fi
}

## Converts the given file to UTF-8 encoding
to_utf8 ()
{
	if ! hash iconv &> /dev/null; then error critical "iconv is missing...\n" 106; fi
	local CURRCS=$(file -b "$1" | tr '[:lower:]' '[:upper:]' | grep -Eo '^[[:graph:]]+')

	if ! hash iconv &> /dev/null; then error critical "iconv is missing...\n" 105; fi
	west_rx='^(eng|(fr|sw|ic|qu)e|(ge|af|no|ca)r|p(o[br]|ap)|s[np]a|d(an|ut)|gsw|(fi|hu)n|'
	west_rx+='i(nd|ta)|a(rg|st)|baq|grn|l(at|tz)|mlg|n(ah|ds|no|ob)|orm|t(up|pi)|xho|zul|cp[efp])$'
	if [[ $(printf "$CURRCS" | grep -Ec 'UTF.?8') -gt 0 ]]; then return
	elif [[ $(printf "$CURRCS" | grep -Ec '(ISO.?8859|WINDOWS)') -gt 0 ]]; then
		if [[ "$2" =~ $west_rx ]]; then CURRCS="WINDOWS-1252" # western latin
		elif [[ "$2" =~ ^(ara|per|fas|urd)$ ]]; then CURRCS="WINDOWS-1256" # arabic
		elif [[ "$2" =~ ^(rus|bul|arm|kaz|mac)$ ]]; then CURRCS="WINDOWS-1251" # cyrillic
		elif [[ "$2" =~ ^(cze|pol|rum|h(rv|un)|sl[ov]|bos)$ ]]; then CURRCS="WINDOWS-1250" # eastern-european
		elif [[ "$2" == vie ]]; then CURRCS="WINDOWS-1258" # vietnamese
		elif [[ "$2" == tha ]]; then CURRCS="WINDOWS-874" # thai
		elif [[ "$2" == tur ]]; then CURRCS="WINDOWS-1254" # turkish
		elif [[ "$2" =~ ^(gr[ec]|ell)$ ]]; then CURRCS="WINDOWS-1253" # greek
		elif [[ "$2" =~ ^(heb|yid)$ ]]; then CURRCS="WINDOWS-1255" # hebrew
		#elif [[ "$2" =~ ^(l(av|it))$ ]]; then local CURRCS="WINDOWS-1257" # baltic
		#elif [[ "$2" == chi ]]; then CURRCS="BIG5" # chinese
		# devanagari
		# 
		else error warning "Could not guess the charset of '$1'\n"; fi
		fi

	if iconv -f "$CURRCS" -t UTF8 "$1" &> "$1.utf8.tmp"; then 
		mv -f "$1.utf8.tmp" "$1" &> /dev/null
	else
		rm -f "$1.utf8.tmp" &> /dev/null
		error warning "Failed to convert '$1' to UTF-8\n"
		fi
	# est :: 1252 vs 1257 
	# lav, lit :: 1250 vs 1257
	# srp :: 1250 vs 1251
	# swa :: 1252 vs 1256
	# chi :: BIG5 vs GBK vs 936
	# ukr :: 1252 vs 1251
}

# SETTING THE DEFAULT VALUES OF THE MAIN VARIABLES
TEST_MODE_=false
INPUT_=""
RENAME_ONLY_=false
REMOVE_REPLACE_=false
REMOVE_ALL_=false
ADD_SUBTITLES_=false
AAC_AUDIO_=false
AAC_SETTINGS_=""
COVER_FILE_=""
TEMP_COVER_FILE_=false
AUDIO_TRACK_="NULL"
SUB_TRACKS_=""
SUB_EXTRA_OPTIONS_=""
ATTACH_OPTIONS_="--no-attachments"
VIDEO_LANG_=""
AUDIO_LANG_=""
TRACK_0_="--language 0:LANGCODE --default-track 0:yes --forced-track 0:yes"
TRACK_1_="--language 1:LANGCODE --default-track 1:yes --forced-track 1:yes"
COVER_="--attachment-mime-type image/jpeg --attachment-name cover.jpg --attach-file 'FILE'"
PREVIOUS__LINES_=""
FINAL_MKVMERGE_LINE_=""

# ABORTING IF 'mkvmerge' IS MISSING
if ! hash mkvmerge &> /dev/null; then error critical "mkvmerge is missing...\n" 100; fi

# PROCESSING THE COMMAND LINE
i=1; j=0; while [[ $i -le $# ]]; do
	buffer="${!i}"
	if [[ "$buffer" =~ ^-(h|-?help)$ ]]; then help_message full
	elif [[ "$buffer" =~ ^-(hl|-list-languages)$ ]]; then help_message languages
	elif [[ "$buffer" =~ ^-(\?|-get-command-line)$ ]]; then TEST_MODE_=true
	elif [[ "$buffer" =~ ^--?prepare$ ]]; then install_me dependencies
	elif [[ "$buffer" =~ ^--?install$ ]]; then install_me full
	elif [[ "$buffer" =~ ^-(i|-input)$ ]]; then 
		if [[ "$INPUT_" == "" ]]; then i=$((i + 1)); INPUT_="${!i}"; fi
	elif [[ "$buffer" =~ ^-(o|-output)$ ]]; then i=$((i + 1)); OUTPUT_="${!i}"
	elif [[ "$buffer" =~ ^-(O|-default-output)$ ]]; then OUTPUT_="predefined"
	elif [[ "$buffer" =~ ^-(n|-rename-to-default)$ ]]; then OUTPUT_="predefined"; RENAME_ONLY_=true
	elif [[ "$buffer" =~ ^-(r|-remove-input-file)$ ]]; then REMOVE_REPLACE_=true
	elif [[ "$buffer" =~ ^-(R|-remove-all-inputs)$ ]]; then REMOVE_REPLACE_=true; REMOVE_ALL_=true
	elif [[ "$buffer" =~ ^-(s|-subtitles)$ ]]; then
		i=$((i + 1))
		ADD_SUBTITLES_=true
		SUB_LIST_[j]="${!i}"
		j=$((j + 1))
	elif [[ "$buffer" =~ ^-(t|-title)$ ]]; then i=$((i + 1)); TITLE_="${!i}"
	elif [[ "$buffer" =~ ^-(c|-cover)$ ]]; then i=$((i + 1)); COVER_FILE_="${!i}"
	elif [[ "$buffer" =~ ^-(L|-video-language)$ ]]; then i=$((i + 1)); VIDEO_LANG_=$(lang_code "${!i}")
	elif [[ "$buffer" =~ ^-(l|-audio-language)$ ]]; then i=$((i + 1)); AUDIO_LANG_=$(lang_code "${!i}")
	elif [[ "$buffer" =~ ^-(a|-aac-audio)$ ]]; then AAC_AUDIO_=true; i=$((i + 1)); AAC_SETTINGS_="${!i}"
	else
		if ! [[ ( -f "$buffer" ) && ( -r "$buffer" ) ]]; then printf "'$buffer' is not a valid file...\n"
		elif [[ ( $(xdg-mime query filetype "$buffer") == image* ) && ( "$COVER_FILE_" == "" ) ]]; then
			COVER_FILE_="$buffer"
		elif [[ "$INPUT_" == "" ]]; then INPUT_="$buffer"; fi
		fi
	i=$((i + 1))
	done
printf "\n------------------------------------------ ----- ---- --- -- -\n\n"

# ABORTING IF 'ffmpeg' IS MISSING AND SEEMS TO BE NEEDED
if ! hash ffmpeg &> /dev/null && \
		[[ $(grep -Ec '\.(s(a?mi|ub|sa)|(as|mk)s)' <<< ${SUB_LIST_[@],,}) -gt 0 ]] || 
		[[ "$AAC_AUDIO_" == true ]]; then
	error critical "ffmpeg is missing...\n" 101
	fi

# ABORTING IF 'imagemagick' IS MISSING AND SEEMS TO BE NEEDED
if ! hash convert &> /dev/null && [[ -f "$COVER_FILE_" ]]; then
	error critical "imagemagick is missing...\n" 102
	fi

# CHECKING THE INPUT FILE AND ANALYZING ITS CONTENT
if [[ ( "$INPUT_" == "" ) || !( -f "$INPUT_" ) || !( -r "$INPUT_" ) ]]; then 
	printf "Input file is missing or was not specified\n"
	help_message
else
	if ! hash mediainfo &> /dev/null; then 
		error critical "mediainfo is missing...\n" 103
	elif [[ $(mediainfo --language=raw --full "$INPUT_" | grep -Ec '^[Aa]udio[\t ]+#[^:]*$') -gt 1 ]]; then
		for i in `seq 1 20`; do
			buffer=$(mediainfo "$INPUT_" | \
					sed -n '/^Audio #'$i'[^[:graph:]]*$/,/^Audio #'$((i+1))'[^[:graph:]]*$/p' | \
					grep '^Language' | sed -r 's/^.*:[\t ]*([[:alpha:]]+)[^[:graph:]]*$/\1/')
			if [[ ( "${buffer^^}" == "${AUDIO_LANG_^^}" ) || ( $(lang_code "$buffer") == "${AUDIO_LANG_,,}" ) ]]; then
				AUDIO_TRACK_=$(mediainfo "$INPUT_" | \
						sed -n '/^Audio #'$i'[^[:graph:]]*$/,/^Audio #'$((i+1))'[^[:graph:]]*$/p' | \ 
						grep '^ID' | sed -r 's/^.*:[\t ]+([[:digit:]]{1,2})[^[:graph:]]*$/\1/')
				fi
			done
		if [[ "$AUDIO_TRACK_" == "NULL" ]]; then
			error warning "There are multiple audio tracks in the input file: \n"
			read -p "Which one is to be kept? [ID] " AUDIO_TRACK_
			fi
	else
		AUDIO_TRACK_=1
		fi
	declare -r VIDEO_COD_=$(mediainfo --language=raw --full --inform="Video;%Codec/Family%" "$INPUT_")
	declare -r AUDIO_COD_=$(mediainfo --language=raw --full --inform="Audio;%Codec/Family%" "$INPUT_")
	declare -r AUDIO_CHA_=$(mediainfo --language=raw --full --inform="Audio;%Channel(s)%" "$INPUT_")
	buffer=$(mediainfo --full --language=raw --inform="Video;%Language/String3%" "$INPUT_")
	if [[ ( "$VIDEO_LANG_" =~ ^(UND)?$ ) && ( "$buffer" =~ ^...$ ) ]]; then VIDEO_LANG_="$buffer"
	elif [[ "$VIDEO_LANG_" == "" ]]; then VIDEO_LANG_="und"; fi
	buffer=$(mediainfo --full --language=raw --inform="Audio;%Language/String3%" "$INPUT_")
	if [[ ( "$AUDIO_LANG_" =~ ^(UND)?$ ) && ( "$buffer" =~ ^...$ ) ]]; then AUDIO_LANG_="$buffer"
	elif [[ "$AUDIO_LANG_" == "" ]]; then AUDIO_LANG_="und"; fi
	fi

# SETTING (OR PROMPTING FOR) A TITLE (METADATA) IF NONE WAS SET PREVIOUSLY
if [[ ( "$TITLE_" == "" ) && ( "$INPUT_" == *.mkv ) ]]; then
	TITLE_=$(mkvinfo "$INPUT_" | grep [Tt]itle | sed -r 's/^.*?: (.*)$/\1/')
	fi
if [[ "$TITLE_" == "" ]]; then
	read -p "Do you want to enter a title for the file now? [Y/n] " buffer
	if [[ "$buffer" == [Nn]* ]]; then TITLE_="${INPUT_##*/}"; TITLE_="${TITLE_%%.*}"
	else read -p "Title: " TITLE_; fi
	fi

# CHECKING THE OUTPUT PATH AND FIXING IT, IF NEEDED AND POSSIBLE
if [[ "$OUTPUT_" == "" ]]; then 
	OUTPUT_="${INPUT_%.*}.mkv"
	if [[ ( "$REMOVE_REPLACE_" == true ) && ( "$INPUT_" == "$OUTPUT_" ) ]]; then OUTPUT_="$OUTPUT_.tmp"; fi
elif [[ "$OUTPUT_" == "predefined" ]]; then
	if [[ "$INPUT_" == */* ]]; then OUTPUT_="${INPUT_%/*}/$TITLE_"
	else OUTPUT_="$TITLE_"; fi
	if ! hash mediainfo &> /dev/null; then error critical "mediainfo is missing...\n" 103; fi
	RESOLUTION_=$(mediainfo --language=raw --full --inform="Video;%Height%" "$INPUT_")
	if [[ $RESOLUTION_ -gt 2000 ]]; then RESOLUTION_="4K"
	elif [[ $RESOLUTION_ -gt 800 ]]; then RESOLUTION_="1080p"
	elif [[ $RESOLUTION_ -gt 500 ]]; then RESOLUTION_="720p"
	elif [[ $RESOLUTION_ -gt 380 ]]; then RESOLUTION_="480p"
	elif [[ $RESOLUTION_ -gt 250 ]]; then RESOLUTION_="360p"
	else RESOLUTION_="240p"; fi
	OUTPUT_="$OUTPUT_ $RESOLUTION_ $VIDEO_COD_ $AUDIO_COD_.mkv"
	if [[ "$RENAME_ONLY_" == true ]]; then FINAL_MKVMERGE_LINE_="mv -vi \"$INPUT_\" \"$OUTPUT_\"\n"; fi
elif [[ -d "$OUTPUT_" ]]; then
	buffer=${INPUT_##*/}
	OUTPUT_="${OUTPUT_%/}/${buffer%.*}.mkv"
elif [[ "$OUTPUT_" != *.mkv ]]; then
	OUTPUT_=$(printf "$OUTPUT_" | sed -r 's/\.[[:alnum:]]{1,4}/.mkv/')
	fi
if [[ "$OUTPUT_" == "$INPUT_" ]]; then
	printf "\nOutput would overwrite input...\nIf that is what you want, enable the '-r' option\n"
	exit 65
	fi

# PRINTING INPUT/OUTPUT INFORMATION
printf "INPUT:\n\033[2m$INPUT_\033[0m\n"
printf "\033[2;3;7mAudio: $AUDIO_COD_ [$AUDIO_CHA channels]\033[0;0;0m\n"
printf "\033[2;3;7mVideo: $VIDEO_COD_ [$RESOLUTION_]\033[0;0;0m\n"
printf "OUTPUT:\n\033[2m$OUTPUT_\033[0m\n"
if [[ "$AAC_AUDIO_" == true ]]; then printf "\033[2;3;7mAudio: AAC [$AUDIO_CHA channels]\033[0;0;0m\n"
else printf "\033[2;3;7mAudio: $AUDIO_COD_ [$AUDIO_CHA channels]\033[0;0;0m\n"; fi
printf "\033[2;3;7mVideo: $VIDEO_COD_ [$RESOLUTION_]\033[0;0;0m\n"

# PROCESSING ANY GIVEN SUBTITLES
if [[ "$ADD_SUBTITLES_" == true ]]; then
	printf "SUBTITLES:\n"
	i=0
	SUB_f=$(if [[ "$AAC_AUDIO_" == true ]]; then printf "2"; else printf "1"; fi)
	while [[ "$i" -lt "$j" ]]; do
		if ! [[ "${SUB_LIST_[i]}" =~ ^[[:alpha:]]{3}:.*$ ]]; then
			if [[ "${SUB_LIST_[i]}" =~ ^[[:alpha:]]{3,15}:.*$ ]]; then
				SUB_LANG_=$(lang_code $(printf "${SUB_LIST_[i]}" | sed -r 's/^([[:alpha:]]{3,15}):.*$/\1/'))
				fi
			if [[ "$SUB_LANG_" == "UND" ]] || \
					[[ "${SUB_LIST_[i],,}" =~ ^.*[[:alpha:]]{3}\.(s(sa|rt|ub|a?mi)|ass)$ ]]; then
				SUB_LANG_=$(lang_code $(printf "${SUB_LIST_[i]}" | sed -r 's/^.*([[:alpha:]]{3})\....$/\1/'))
				fi
			if [[ "$SUB_LANG_" == "UND" ]]; then
				printf "\033[2;3;33m"; 
				read -p "Name (in english or ISO 639-2 code) the language of '${SUB_LIST_[i]##*/}': " buffer
				printf "\033[0;0;0m"
				SUB_LANG_=$(lang_code "$buffer")
				SUB_LIST_[i]=$(printf "${SUB_LIST_[i]}" | sed -r 's/^[[:alpha:]]{,12}://')
				fi
		else
			SUB_LANG_=$(lang_code "${SUB_LIST_[i]:0:3}")
			SUB_LIST_[i]="${SUB_LIST_[i]:4}"
			fi
		
		if [[ "$SUB_LANG_" == "UND" ]]; then
			printf "Unrecognized language '$buffer'\n"
			printf "Try '${0##*/} -hl' for a list of accepted languages and codes\n"
			exit 95
			fi
		SUB_IS_TEMP_[i]=false
		if ! [[ "${SUB_LIST_[i]}" == *.srt ]]; then
			if [[ "$TEST_MODE_" == true ]]; then
				PREVIOUS__LINES_+="ffmpeg -i \"${SUB_LIST_[i]}\" -vn -an -scodec srt \"${SUB_LIST_[i]%.*}.srt\"; "
			elif ffmpeg -i "${SUB_LIST_[i]}" -vn -an -scodec srt "${SUB_LIST_[i]%.*}.srt"; then
				SUB_IS_TEMP_[i]=true
			else 
				error critical "'${SUB_LIST_[i]}' contains no valid subtitles\n" 21
				fi
			fi
		printf "\033[2m${SUB_LIST_[i]##*/} -> $SUB_LANG_"
		if [[ $(printf "${SUB_LIST_[i]}" | grep -Ec '^(.*[^[:alpha:]])?(SDH|sdh)([^[:alpha:]].*)?$') -gt 0 ]]; then
			SUB_EXTRA_OPTIONS_+=" --track-name 0:'SDH'"
			printf " [SDH]"
			fi
		printf "\033[0m\n"
		SUB_EXTRA_OPTIONS_+=" --language 0:$SUB_LANG_ --sub-charset 0:UTF-8"
		SUB_EXTRA_OPTIONS_+=" --default-track 0:no --forced-track 0:no"
		SUB_EXTRA_OPTIONS_+=" --subtitle-tracks 0 '(' \"${SUB_LIST_[i]%.*}.srt\" ')'"
		SUB_TRACKS_=",$SUB_f:0"
		i=$((i + 1))
		SUB_f=$((SUB_f + 1))
		done
	SUB_EXTRA_OPTIONS_="${SUB_EXTRA_OPTIONS_# }"
	fi

# PROCESSING ANY GIVEN COVER IMAGE
if [[ "$COVER_FILE_" != "" ]]; then 
	if ! [[ ( -f "$COVER_FILE_" ) && ( -r "$COVER_FILE_" ) ]]; then
		if wget -O "$COVER_FILE_" -c "/tmp/nicemkv.cover.tmp"; then
			COVER_FILE_="/tmp/nicemkv.cover.tmp"
			TEMP_COVER_FILE_=true
		else 
			error critical "Cannot access '$2'\n" 19
			fi
		fi
	if [[ $(xdg-mime query filetype "$COVER_FILE_") != 'image/jpeg'* ]]; then
		convert "$COVER_FILE_" -format jpg -quality 99 "${COVER_FILE_%.*}.jpg.tmp"
		if [[ $? -ne 0 ]]; then
			error critical "'$2' is not a valid image file\n" 10
			fi
		OLD_COVER_FILE_="$COVER_FILE_"
		COVER_FILE_="${COVER_FILE_%.*}.jpg.tmp"
		TEMP_COVER_FILE_=true
		fi
	COVER_WIDTH=$(identify -ping -format '%W\n%H' "$COVER_FILE_" | sed '1q;d')
	COVER_HEIGHT=$(identify -ping -format '%W\n%H' "$COVER_FILE_" | sed '2q;d')
	COVER_IS_POSTER=$(((COVER_HEIGHT * 200) / (COVER_WIDTH / 5)))
	if [[ ( "$COVER_IS_POSTER" -ge 1490 ) && ( "$COVER_IS_POSTER" -le 1510 ) ]]; then
		if [[ ( "$COVER_WIDTH" -ge 595 ) && ( "$COVER_HEIGHT" -ge 893 ) ]]; then
			if [[ "$TEMP_COVER_FILE_" == true ]]; then
				convert "$COVER_FILE_" -resize 600x900\! "$COVER_FILE_" 
			else
				convert "$COVER_FILE_" -resize 600x900\! "$COVER_FILE_.tmp"
				OLD_COVER_FILE_="$COVER_FILE_"
				COVER_FILE_="$COVER_FILE_.tmp"
				TEMP_COVER_FILE_=true
				fi
		else
			printf "The cover seems to be a movie poster, but it is too small...\n"
			read -p "Proceed anyway? [y/N] " buffer
			if [[ "$buffer" != [Yy]* ]]; then exit 11; fi
			fi
		fi
else
	if [[ ( "$INPUT_" == *.mkv ) && ( $(mkvinfo "$INPUT_" | grep -Eic 'cover\.jpe?g') -eq 1 ) ]]; then
		ATTACH_OPTIONS_=$(mkvinfo "$INPUT_" | sed -r -n '1,/.*cover\.jpe?g.*/p' | grep -c -i 'attached')
		ATTACH_OPTIONS_="--attachments $ATTACH_OPTIONS_"
		COVER_=""
	else
		if ! hash totem-video-thumbnailer &> /dev/null; then 
			error warning "totem-video-thumbnailer is missing...\n"
			COVER_=""
		else
			totem-video-thumbnailer -j -v -s 600 -t 23 "$INPUT_" "$INPUT_.thumbnail.jpg"
			COVER_FILE_="$INPUT_.thumbnail.jpg"
			TEMP_COVER_FILE_=true
			fi
		fi
	fi
if [[ ( "$TEMP_COVER_FILE_" == true ) && ( "$REMOVE_ALL_" == true ) && ( "$TEST_MODE_" == false ) ]]; then 
	rm -f "$OLD_COVER_FILE_"
	fi
if [[ -f "$COVER_FILE_" ]]; then 
	printf "COVER IMAGE:\n\033[2m${COVER_FILE_##*/} -> "
	printf "${COVER_WIDTH}x$COVER_HEIGHT\033[0m\n"
	fi

# CONVERTING THE INPUT'S AUDIO TO AAC
if [[ ( "$AAC_AUDIO_" == true ) && ( "$AUDIO_COD" != "AAC" ) && ( "$RENAME_ONLY_" == false ) ]]; then
	if [[ "$AAC_SETTINGS_" =~ ^(([[:digit:]]{2,5}k|[[:digit:]]{1,2}M)(b(its?)?([p/]s(ec)?)?)?|([Vv][Bb][Rr]|~)[1-5])$ ]]; then
		if [[ "$AAC_SETTINGS" =~ ^[Vv][Bb][Rr].* ]]; then AAC_QUALITY_="-vbr ${AAC_SETTINGS_:3:1}"
		elif [[ "$AAC_SETTINGS" =~ ^~.* ]]; then AAC_QUALITY_="-vbr ${AAC_SETTINGS_:1:1}"
		else AAC_QUALITY_="-ab ${AAC_SETTINGS_//[^[:digit:]kM]//}"; fi
	else
		error critical "Invalid AAC audio track specification '$AAC_SETTINGS'\n" 50
		fi
	if ! [[ -e '/usr/include/fdk-aac/aacenc_lib.h' ]]; then 
		error critical "libfdk-aac-dev is missing...\n" 51
		fi
	if [[ "$TEST_MODE_" == true ]]; then 
		printf "\nffmpeg -v quiet -hide-banner -i \"$INPUT_\" -vn -sn -acodec libfdk_aac -ac $AUDIO_CHA_ $AAC_QUALITY_ \"${INPUT_%.*}.aac\"\n"
	elif ! ffmpeg -v quiet -hide-banner -i "$INPUT_" -vn -sn -acodec libfdk_aac -ac $AUDIO_CHA_ $AAC_QUALITY_ "${INPUT_%.*}.aac"; then
		AAC_AUDIO_=false
		TRACK_1_="$TRACK_0_"
		error critical "Failed to convert input audio to AAC...\n" 51
		fi
	fi

# CLEANING THE COVER IMAGE BEFORE USING IT, IF ONE EXISTS
if [[ -f "$COVER_FILE_" ]] && \
		[[ ( "$COVER_FILE_" =~ ^.*\.[Jj][Pp][Ee]?[Gg]$ ) && ( "$RENAME_ONLY_" == false ) ]]; then
	if [[ "$TEST_MODE_" == true ]]; then 
		PREVIOUS__LINES_+="jpegoptim --strip-all \"$COVER_FILE_\"; mat \"$COVER_FILE_\"; "
	else 
		jpegoptim --strip-all "$COVER_FILE_"
		mat "$COVER_FILE_"
		fi
	fi

# CONSTRUCTING THE 'mkvmerge' COMMAND LINE
if [[ "$RENAME_ONLY_" == false ]]; then
if [[ "$AAC_AUDIO_" == true ]]; then FINAL_MKVMERGE_LINE_+="mkvmerge -v --output \"$OUTPUT_\" ${TRACK_0_/LANGCODE/${VIDEO_LANG_}} --no-audio-tracks --no-track-tags --no-global-tags $ATTACH_OPTIONS_ --video-tracks 0 '(' \"$INPUT_\" ')' ${TRACK_1_/LANGCODE/${AUDIO_LANG_}} --no-video-tracks --no-track-tags --no-global-tags --no-chapters --no-buttons --audio-tracks 0 '(' \"${INPUT_%.*}.aac\" ')' $SUB_EXTRA_OPTIONS_ --track-order \"0:0,1:0$SUB_TRACKS_\" ${COVER_//FILE/${COVER_FILE_}} --title \"$TITLE_\" ; rm -f \"${INPUT_%.*}.aac\""
else FINAL_MKVMERGE_LINE_+="mkvmerge -v --output \"$OUTPUT_\" ${TRACK_0_/LANGCODE/${VIDEO_LANG_}} ${TRACK_1_/LANGCODE/${AUDIO_LANG_}} --no-track-tags --no-global-tags $ATTACH_OPTIONS_ --audio-tracks $AUDIO_TRACK_ --video-tracks 0 '(' \"$INPUT_\" ')' $SUB_EXTRA_OPTIONS_ --track-order \"0:0,0:1$SUB_TRACKS_\" ${COVER_//FILE/${COVER_FILE_}} --title \"$TITLE_\""; fi
fi

# RUNNING OR PRINTING THE FINAL COMMAND LINE
printf "\n------------------------------------------ ----- ---- --- -- -\n\n"
if [[ "$TEST_MODE_" == false ]]; then 
	bash -c "$FINAL_MKVMERGE_LINE_"
else 
	printf "GENERATED LOW-LEVEL COMMAND LINE:\n"
	printf "\033[2;36m$PREVIOUS__LINES_$FINAL_MKVMERGE_LINE_\033[0m\n\n"
	fi
	
# REPLACING/REMOVING INPUT FILES, AS WANTED
if [[ "$REMOVE_REPLACE_" == true ]]; then
	if [[ "$OUTPUT_" == "$INPUT_.tmp" ]]; then mv -f "$OUTPUT_" "$INPUT_"
	else rm -f "$INPUT_"; fi
	fi
if [[ "$ADD_SUBTITLES_" == true ]]; then
	i=0; while [[ "$i" -lt "$j" ]]; do
		if [[ "${SUB_IS_TEMP_[i]}" == true ]]; then rm -f "${SUB_LIST_[i]%.*}.srt"; fi
		i=$((i + 1))
		done
	fi
if [[ ( "$TEMP_COVER_FILE_" == true ) || ( "$REMOVE_ALL_" == true ) ]]; then 
	rm -f "$COVER_FILE_"
	fi	
if [[ "$REMOVE_ALL_" == true ]]; then
	if [[ "$ADD_SUBTITLES_" == true ]]; then
		i=0; while [[ "$i" -lt "$j" ]]; do
			rm -f "${SUB_LIST_[i]}" &> /dev/null
			i=$((i + 1))
			done
		fi
	fi

