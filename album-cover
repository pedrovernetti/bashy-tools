#!/bin/bash

 # ==================================================== #
 # This script looks better in a maximized window, on   #
 # 1360px or wider screens...                           #
 #                                                      #
 # Run it with the '-h' option for better understanding #
 #                                                      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # Originally written by <pedrovernetti@gmail.com>      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # tested in / thought for Ubuntu 16.04 and 18.04       #
 # ==================================================== #

# HELP ------------------------------------------------------------------------
help_message ()
{
	printf "Usage: ${0##*/} [OPTIONS] MUSIC_ALBUM_FOLDER [MUSIC_ALBUM_COVER]\n\n"
	printf "  Inserts the given Album Cover into every audio file inside the given folder.\n\n"
	if [[ "$1" == "full" ]]; then
		printf "  Options:\n\n"
		printf "  -h        print this help message and exit\n"
		printf "  -prepare  install dependencies (\033[1mmust be runned once\033[0m)\n"
		printf "  -C        auto-rename and move the cover image file\n"
		printf "  -i        try using a cover image file inside the folder\n"
		printf "  -J        remove known junk files inside the folder\n"
		printf "  -Q        do not complain about non-square cover images\n\n"
		printf "  -T        do not clear the thumbnails cache after running\n\n"
	    printf "  Cover image must be of at least 500x500 and supported by imagemagick.\n"
	    printf "  Images larger than 500x500 are automaticaly copied and scaled down.\n"
	    printf "  The metadata inside the images are automaticaly erased to save space.\n"
		printf "  Non-JPEG/PNG cover images are converted before being attached.\n"
	    printf "  Previous album arts are NOT removed from mp4-style audio files.\n"
	    printf "  Audio format detection relies on file extensions.\n"
	    printf "  Thumbnails cache is cleared in the end, so that the changes can be noticed.\n\n"
	    exit 0
	else
		exit 1
		fi
}

# INSTALLING DEPENDENCIES IF DEMANDED -----------------------------------------
install_dependencies ()
{
    sudo apt-get -y install atomicparsley
    sudo apt-get -y install eyed3
    sudo apt-get -y install imagemagick
    sudo apt-get -y install jpegoptim
    sudo apt-get -y install wget
    exit
}

# SETTING DEFAULT VALUES ------------------------------------------------------
remove_cover_rx='^([-._ ]+|[Rr][Ee][Mm][Oo][Vv][Ee]|[Dd][Ee][Ll][Ee][Tt][Ee]|'
remove_cover_rx+='[Cc][Ll][Ee][Aa][Rr]|[Nn][Oo][Nn][Ee])$'
weird_image_rx='^.*\.((web|w?bm)p|bm|d(cr|ib)|(bp|mn)g|j(p[2fx]|ng|xr)|tiff?|'
weird_image_rx+='(fl|qt?)if|p[abgnp]m|x[bp]m|c(r[2w]|in)|[hw]dp)$'
weird_image_w_alpha_rx='^.*\.(p(s[bd]|cx)|(gi|wm)f|a(png|i)|svgz?|eps[fi]?|'
weird_image_w_alpha_rx+='ic(o|ns)|vsd)$'
image_rx='^.*\.((jpe?|pn)g|jpe)$'
audio_rx='^.*\.([Mm]([Pp][+234Cc]|4[AaBb])|[Ww][Vv]|[Aa][Pp][Ee]|[Aa][Aa][Cc])$'
junk_rx='^(([Ff][Oo][Ll][Dd][Ee][Rr]|AlbumArt.*)\.((jpe?|pn)g|jpe|bmp)|'
junk_rx+='[Tt][Hh][Uu][Mm][Bb][Ss]\.[Dd][Bb])$'
MOVE_ART=false
COVER_IS_INSIDE=false
REMOVE_JUNK=false
OK_NONSQUARE=false
REMOVE_COVER=false
KEEP_THUMBS_CACHE=false
IS_TEMP=false

# DEALING WITH COMMAND LINE ARGUMENTS -----------------------------------------
ARG_A="${@:(-2):1}"
ARG_B="${!#}"
for i in `seq 1 $#`; do
    if [[ "${!i}" =~ ^-(h|-?help)$ ]]; then 
        help_message full
    elif [[ "${!i}" =~ ^--?prepare$ ]]; then 
        install_dependencies
    elif [[ "${!i}" =~ ^-(C|-move-cover)$ ]]; then 
        MOVE_ART=true
    elif [[ "${!i}" =~ ^-(i|-cover-is-inside)$ ]]; then 
        COVER_IS_INSIDE=true
        ARG_A="$ARG_B"
    elif [[ "${!i}" =~ ^-(J|-remove-junk)$ ]]; then 
        REMOVE_JUNK=true
    elif [[ "${!i}" =~ ^-(Q|-nonsquare-ok)$ ]]; then 
        OK_NONSQUARE=true
    elif [[ "${!i}" =~ ^-(r|-remove-cover)$ ]]; then 
        REMOVE_COVER=true
    elif [[ "${!i}" =~ ^-(T|-keep-thumbnails-cache)$ ]]; then 
        KEEP_THUMBS_CACHE=true
        fi
    done
if [[ ( $# -eq 0 ) || ( "$ARG_A" == "$0" ) ]]; then
    help_message short
elif ! [[ -d "$ARG_A" ]]; then
    echo "'$ARG_A' is not a folder"
    exit 99
elif ! [[ -f "$ARG_B" ]]; then
    if [[ "$COVER_IS_INSIDE" != true ]]; then
        echo "no valid file given as cover image"
        exit 99
        fi
    fi

# CHECKING DEPENDENCIES -------------------------------------------------------
if ! hash AtomicParsley &> /dev/null; then 
    printf "Unmet dependency: AtomicParsley\n"; exit 100; fi
if ! hash eyeD3 &> /dev/null; then 
    printf "Unmet dependency: eyeD3\n"; exit 100; fi
if ! hash convert &> /dev/null; then 
    printf "Unmet dependency: imagemagick\n"; exit 100; fi
if ! hash jpegoptim &> /dev/null; then 
    printf "Unmet dependency: jpegoptim\n"; exit 100; fi
if ! hash wget &> /dev/null; then 
    printf "Unmet dependency: wget\n"; exit 100; fi

# LOOKING FOR A COVER IMAGE INSIDE THE FOLDER WHEN DEMANDED -------------------
if [[ "$COVER_IS_INSIDE" == true ]]; then
    lowercase_cover_rx='^.*\.(jp(e?g|e)|png)$'
    possible_covers_count=0
    while read -r i; do
        if [[ "${i,,}" =~ $lowercase_cover_rx ]]; then
            possible_covers_count=$((possible_covers_count + 1))
            cover_found="$i"
            fi
        done <<< $(find "$ARG_A" -maxdepth 1 -type f)
    if [[ "$possible_covers_count" -eq 1 ]]; then
        ARG_B="$cover_found"
    else
		echo "no cover image candidate found"
        exit 20
        fi
    fi
        
# PREPARING TO REMOVE THE COVER WHEN WANTED -----------------------------------
if [[ ( "$ARG_B" =~ $remove_cover_rx ) || ( "$REMOVE_COVER" == true ) ]]; then
	art="REMOVE_ALL"
	
# DEALING WITH THE COVER IMAGE ------------------------------------------------
elif [[ ( -f "$ARG_B" ) && ( -r "$ARG_B" ) ]]; then 
    art="$ARG_B"
elif wget -O /tmp/aa.cover.tmp -c "$ARG_B" &> /dev/null; then 
    art="/tmp/aa.cover.tmp"; IS_TEMP=true
else 
    echo "Cannot access '$ARG_B'"
    exit 3
    fi
    
# CHECKING IMAGE TYPE AND CONVERTING IF NEEDED --------------------------------
art_lowercase=$(echo "$art" | tr '[:upper:]' '[:lower:]')
if [[ "$art_lowercase" =~ $weird_image_rx ]]; then
	conv_art="${art%.*}\.$RANDOM\.${art##*.}"
	convert "$art" -format jpg -quality 95 "$conv_art"
	IS_TEMP=true
elif [[ "$art_lowercase" =~ $weird_image_w_alpha_rx ]]; then
	conv_art="${art%.*}\.$RANDOM\.${art##*.}"
	convert "$art" -format png "$conv_art"
	IS_TEMP=true
elif ! [[ "$art_lowercase" =~ $image_rx ]]; then
    if [[ $(xdg-mime query filetype "$art") =~ ^image/(jpeg|png)$ ]]; then
        echo "'$ARG_B' is not supported"
    else
	    echo "'$ARG_B' is not an image"
	    fi
	exit 9
	fi

# CHECKING IMAGE SIZE AND SCALING IF NEEDED -----------------------------------
W=$(identify -ping -format '%W\n%H' "$art" | sed '1q;d')
H=$(identify -ping -format '%W\n%H' "$art" | sed '2q;d')
if [[ $W -ge $H ]]; then IS_SQUARE=$((W / ((W - H) + 1)))
elif [[ $H -gt $W ]]; then IS_SQUARE=$((H / ((H - W) + 1))); fi	
if [[ ( "$IS_SQUARE" -lt 100 ) && ( "$OK_NONSQUARE" == false ) ]]; then
    printf "Choosen image is not square:\n$ARG_B\n"
	read -p "Are you sure this is the right one? [Y/n] " buffer
	if [[ "$buffer" == [Nn]* ]]; then exit 0; fi
	if hash gimp; then
		read -p "Do you want to open it on GIMP for some adjusts? [y/N] " buffer
		if [[ "$buffer" == [Yy]* ]]; then gimp "$art"; fi
		fi
	fi
if [[ ( $W -gt 500 ) || ( $H -gt 500 ) ]]; then
	echo "Big image... [$W x $H]"
	resized_art="${art%.*}.$RANDOM.${art##*.}"
	if [[ "$IS_SQUARE" -ge 100 ]]; then 
	    echo '[]'
	    convert "$art" -resize 500x500\! "$resized_art"
	elif [[ $W -gt $H ]]; then 
	    convert "$art" -scale 500x "$resized_art"
	else 
	    convert "$art" -scale x500 "$resized_art"
	    fi
	if [[ "$IS_TEMP" == true ]]; then rm -f "$art" &> /dev/null; fi
	art="$resized_art"
	IS_TEMP=true
elif [[ ( $W -lt 499 ) || ( $H -lt 499 ) ]]; then
	echo "Small image... [$W x $H]"
	exit 11
	fi

# OPTIMIZING JPEG COVER IMAGES ------------------------------------------------
if [[ "$art" == *.jpg ]]; then jpegoptim --strip-all "$art"; fi

# GETTING THE LIST OF AUDIO FILES INSIDE THE GIVEN FOLDER ---------------------
audio_content=$(find "$ARG_A" -regextype posix-extended \
                    -type f -regex "$audio_rx" -printf "%p\n")

# EMBEDDING COVER IMAGES INTO AUDIO FILES -------------------------------------
while read -r buffer; do
	if [[ "$buffer" =~ ^.*\.([Mm][Pp][23]|[Aa][Aa][Cc])$ ]]; then
		eyeD3 -v --to-v2.3 --strict --no-tagging-time-frame --remove-images \
		    "$buffer"
		eyeD3 -v --strict --no-tagging-time-frame --remove-images \
		      -add-image="$art":FRONT_COVER "$buffer"
	elif [[ "$buffer" =~ ^.*\.[Mm](4[AaBb]|[Pp]4)$ ]]; then
		AtomicParsley "$buffer" --artwork "$art"
		mv -f "${buffer%.*}-temp-"*.m4? "$buffer"
	#elif [[ "$buffer" =~ ^.*\.([Mm][Pp][Cc]|[Aa][Pp][Ee])$ ]]; then
	#	
	    fi
	done <<< "$audio_content"

# AUTO-RENAMING AND MOVING COVER IMAGE IF WANTED ------------------------------
if [[ "$MOVE_ART" == true ]]; then
    mv -f "$ARG_B" "${ARG_A%/*}/${ARG_A##*/}.${ARG_B##*.}"
    fi
    
# REMOVING JUNK FILES IF WANTED -----------------------------------------------
if [[ "$REMOVE_JUNK" == true ]]; then    
    find "$ARG_A" -type f -regextype posix-extended -regex "$junk_rx" -delete
    fi

# REMOVING THE COVER IMAGE IF IT IS TEMPORARY ---------------------------------
if [[ "$IS_TEMP" == true ]]; then 
    rm -f "$art" &> /dev/null
    fi

# CLEARING THE THUMBNAILS CACHE SO THAT THE CHANGES CAN BE NOTICED ------------
if [[ "$KEEP_THUMBS_CACHE" == false ]]; then
    rm -fr ~/.cache/thumbnails/*/*
    fi


