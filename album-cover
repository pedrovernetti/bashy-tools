#!/bin/bash

 # ==================================================== #
 # This script looks better in a maximized window, on   #
 # 1360px or wider screens...                           #
 #                                                      #
 # Run it with the '-h' option for better understanding #
 #                                                      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # Originally written by <pedrovernetti@gmail.com>      #
 # -- - - - - - - - - - - - - - - - - - - - - - - - - - #
 # tested in / thought for Ubuntu 16.04 and 18.04       #
 # ==================================================== #

# HELP ------------------------------------------------------------------------
help_message ()
{
	printf "Usage: ${0##*/} [OPTIONS] MUSIC_ALBUM_FOLDER [MUSIC_ALBUM_COVER]\n\n"
	printf "  Inserts the given Album Cover into every audio file inside the given folder.\n\n"
	if [[ "$1" == "full" ]]; then
		printf "  Options:\n\n"
		printf "  -h        print this help message and exit\n"
		printf "  -prepare  install dependencies (\033[1mmust be runned once\033[0m)\n"
		printf "  -C        auto-rename and move the cover image file\n"
		printf "  -i        try using a cover image file inside the folder\n"
		printf "  -J        remove known junk files inside the folder\n"
		printf "  -T        do not clear the thumbnails cache after running\n\n"
	    printf "  Cover image must be of at least 500x500 and supported by imagemagick.\n"
	    printf "  Images larger than 500x500 are automaticaly copied and scaled down.\n"
	    printf "  The metadata inside the images are automaticaly erased to save space.\n"
		printf "  Non-JPEG/PNG cover images are converted before being attached.\n"
	    printf "  Previous album arts are NOT removed from mp4-style audio files.\n"
	    printf "  Audio format detection relies on file extensions.\n"
	    printf "  Thumbnails cache is cleared in the end, so that the changes can be noticed.\n\n"
	    exit 0
	else
		exit 1
		fi
}

# DEALING WITH DEPENDENCIES ---------------------------------------------------
install_dependencies ()
{
    sudo apt-get -y install atomicparsley
    sudo apt-get -y install imagemagick
    sudo apt-get -y install jpegoptim
}

if ! hash AtomicParsley; then printf "Unmet dependency: AtomicParsley\n"; exit 100; fi
if ! hash convert; then printf "Unmet dependency: imagemagick\n"; exit 100; fi
if ! hash jpegoptim; then printf "Unmet dependency: jpegoptim\n"; exit 100; fi

# SETTING DEFAULT VALUES ------------------------------------------------------
remove_cover_rx='^([-._ ]+|[Rr][Ee][Mm][Oo][Vv][Ee]|[Dd][Ee][Ll][Ee][Tt][Ee]|'
remove_cover_rx+='[Cc][Ll][Ee][Aa][Rr]|[Nn][Oo][Nn][Ee])$'
weird_image_rx='^.*\.((web|w?bm)p|bm|d(cr|ib)|(bp|mn)g|j(p[2fx]|ng|xr)|tiff?|'
weird_image_rx+='(fl|qt?)if|p[abgnp]m|x[bp]m|c(r[2w]|in)|[hw]dp)$'
weird_image_w_alpha_rx='^.*\.(p(s[bd]|cx)|(gi|wm)f|a(png|i)|svgz?|eps[fi]?|'
weird_image_w_alpha_rx+='ic(o|ns)|vsd)$'
audio_rx='^.*\.([Mm]([Pp][+234Cc]|4[AaBb])|[Ww][Vv]|[Aa][Pp][Ee]|[Aa][Aa][Cc])$'
junk_rx='^(([Ff][Oo][Ll][Dd][Ee][Rr]|AlbumArt.*)\.((jpe?|pn)g|jpe|bmp)|'
junk_rx+='[Tt][Hh][Uu][Mm][Bb][Ss]\.[Dd][Bb])$'
MOVE_ART=false
COVER_IS_INSIDE=false
REMOVE_JUNK=false
REMOVE_COVER=false
KEEP_THUMBS_CACHE=false

# DEALING WITH COMMAND LINE ARGUMENTS -----------------------------------------
ARG_A="${@:(-2):1}"
ARG_B="${!#}"
for i in `seq 1 $#`; do
    if [[ "${!i}" =~ ^-(h|-?help)$ ]]; then 
        help_message full
    elif [[ "${!i}" =~ ^--?prepare$ ]]; then 
        install_dependencies
    elif [[ "${!i}" =~ ^-(C|-move-cover)$ ]]; then 
        MOVE_ART=true
    elif [[ "${!i}" =~ ^-(i|-cover-is-inside)$ ]]; then 
        COVER_IS_INSIDE=true
        ARG_A="$ARG_B"
    elif [[ "${!i}" =~ ^-(J|-remove-junk)$ ]]; then 
        REMOVE_JUNK=true
    elif [[ "${!i}" =~ ^-(r|-remove-cover)$ ]]; then 
        REMOVE_COVER=true
    elif [[ "${!i}" =~ ^-(T|-keep-thumbnails-cache)$ ]]; then 
        KEEP_THUMBS_CACHE=true
        fi
    done
if [[ ( $# -eq 0 ) || ( "$ARG_A" == "$0" ) ]]; then
    help_message short
elif ! [[ -d "$ARG_A" ]]; then
    echo "'$ARG_A' is not a folder"
    exit 99
elif ! [[ -f "$ARG_B" ]]; then
    if [[ "$COVER_IS_INSIDE" != true ]]; then
        echo "no valid file given as cover image"
        exit 99
        fi
    fi

# LOOKING FOR A COVER IMAGE INSIDE THE FOLDER WHEN DEMANDED -------------------
if [[ "$COVER_IS_INSIDE" == true ]]; then
    lowercase_cover_rx='^.*\.(jp(e?g|e)|png)$'
    possible_covers_count=0
    while read -r i; do
        if [[ "${i,,}" =~ $lowercase_cover_rx ]]; then
            possible_covers_count=$((possible_covers_count + 1))
            cover_found="$i"
            fi
        done <<< $(find "$ARG_A" -maxdepth 1 -type f)
    if [[ "$possible_covers_count" -eq 1 ]]; then
        ARG_B="$cover_found"
    else
		echo "no cover image candidate found"
        exit 20
        fi
    fi
        
# PREPARING TO REMOVE THE COVER WHEN WANTED -----------------------------------
if [[ ( "$ARG_B" =~ $remove_cover_rx ) || ( "$REMOVE_COVER" == true ) ]]; then
	art="REMOVE_ALL"
	
# DEALING WITH THE COVER IMAGE ------------------------------------------------
else
	if [[ ( -f "$ARG_B" ) && ( -r "$ARG_B" ) ]]; then art="$ARG_B"
	elif wget -O /tmp/aa.cover.tmp -c "$ARG_B"; then art="/tmp/aa.cover.tmp"; IS_TEMP=true
	else echo "Cannot access '$ARG_B'"; exit 3; fi
	width=$(identify -ping -format '%W\n%H' "$art" | sed '1q;d')
	height=$(identify -ping -format '%W\n%H' "$art" | sed '2q;d')
	IS_TEMP=false
	art_lowercase=$(echo "$art" | tr '[:upper:]' '[:lower:]')

	if [[ "$art_lowercase" =~ $weird_image_rx ]]; then
		conv_art="${art%.*}\.$RANDOM\.${art##*.}"
		convert "$art" -format jpg -quality 95 "$conv_art"
		IS_TEMP=true
	elif [[ "$art_lowercase" =~ $weird_image_w_alpha_rx ]]; then
		conv_art="${art%.*}\.$RANDOM\.${art##*.}"
		convert "$art" -format png "$conv_art"
		IS_TEMP=true
	elif ! [[ ( "$art_lowercase" =~ ^.*\.((jpe?|pn)g|jpe)$ ) || ( $(xdg-mime query filetype "$art") =~ ^image/(jpeg|png)$ ) ]]; then
		echo "'$ARG_B' is not an image"
		exit 9
		fi
	if [[ $width -ge $height ]]; then IS_SQUARE=$((width / ((width - height) + 1)))
	elif [[ $height -gt $width ]]; then IS_SQUARE=$((height / ((height - width) + 1))); fi
	if [[ "$IS_SQUARE" -lt 100 ]]; then
		read -p "Choosen image is not a square, are you sure this is the right one? [Y/n] " buffer
		if [[ "$buffer" == [Nn]* ]]; then exit 0; fi
		if hash gimp; then
			read -p "Do you want to open it on GIMP for some adjusts? [y/N] " buffer
			if [[ "$buffer" == [Yy]* ]]; then gimp "$art"; fi
			fi
		fi
	if [[ ( $width -gt 500 ) || ( $height -gt 500 ) ]]; then
		echo "Big image... [$width x $height]"
		resized_art="${art%.*}.$RANDOM.${art##*.}"
		if [[ "$IS_SQUARE" -ge 100 ]]; then echo '[]'; convert "$art" -resize 500x500\! "$resized_art"
		elif [[ $width -gt $height ]]; then convert "$art" -scale 500x "$resized_art"
		else convert "$art" -scale x500 "$resized_art"; fi
		if [[ "$IS_TEMP" == true ]]; then rm -f "$art" &> /dev/null; fi
		art="$resized_art"
		IS_TEMP=true
	elif [[ ( $width -lt 499 ) || ( $height -lt 499 ) ]]; then
		echo "Small image... [$width x $height]"
		exit 11
		fi
	fi

# OPTIMIZING JPEG COVER IMAGES ------------------------------------------------
if [[ "$art" == *.jpg ]]; then jpegoptim --strip-all "$art"; fi

# GETTING THE LIST OF AUDIO FILES INSIDE THE GIVEN FOLDER ---------------------
audio_content=$(find "$ARG_A" -regextype posix-extended \
                    -type f -regex "$audio_rx" -printf "%p\n")

# EMBEDDING COVER IMAGES INTO AUDIO FILES -------------------------------------
while read -r buffer; do
	if [[ "$buffer" =~ ^.*\.([Mm][Pp][23]|[Aa][Aa][Cc])$ ]]; then
		eyeD3 -v --to-v2.3 --strict --no-tagging-time-frame
		    --remove-images "$buffer"
		eyeD3 -v -add-image="$art":FRONT_COVER --strict --no-tagging-time-frame 
		    --remove-images "$buffer"
	elif [[ "$buffer" =~ ^.*\.[Mm](4[AaBb]|[Pp]4)$ ]]; then
		AtomicParsley "$buffer" --artwork "$art"
		mv -f "${buffer%.*}-temp-"*.m4? "$buffer"
	#elif [[ "$buffer" =~ ^.*\.([Mm][Pp][Cc]|[Aa][Pp][Ee])$ ]]; then
	#	
	    fi
	done <<< "$audio_content"

# AUTO-RENAMING AND MOVING COVER IMAGE IF WANTED ------------------------------
if [[ "$MOVE_ART" == true ]]; then
    AUTO_ART="${art%/*}.${art##*.}"
    AUTO_ART="${AUTO_ART##*/}"
    mv -f "$art" "${ARG_A%/*}/$AUTO_ART"
    fi
    
# REMOVING JUNK FILES IF WANTED -----------------------------------------------
if [[ "$REMOVE_JUNK" == true ]]; then    
    find "$ARG_A" -type f -regextype posix-extended -regex "$junk_rx" -delete
    fi

# REMOVING THE COVER IMAGE IF IT IS TEMPORARY ---------------------------------
if [[ "$IS_TEMP" == true ]]; then 
    rm -f "$art" &> /dev/null
    fi

# CLEARING THE THUMBNAILS CACHE SO THAT THE CHANGES CAN BE NOTICED ------------
if [[ "$KEEP_THUMBS_CACHE" == false ]]; then
    rm -fr ~/.cache/thumbnails/*/*
    fi


